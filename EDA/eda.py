# -*- coding: utf-8 -*-
"""E1_team5_statistical_&_descriptive_analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QuiLNgXwTdMOZoYIwZHTp6Vc_Ky4fJgo

# Cover page, purpose and context.
**Evidence 1** <br>
![Imagen 11-09-24 a las 7.31 p.m..jpg](data:image/jpeg;base64,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IjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/bAEMAAQEBAQEBAgEBAgMCAgIDBAMDAwMEBQQEBAQEBQYFBQUFBQUGBgYGBgYGBgcHBwcHBwgICAgICQkJCQkJCQkJCf/bAEMBAQEBAgICBAICBAkGBQYJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCf/dAAQAOf/aAAwDAQACEQMRAD8A/rgooooOgKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D+uCiiig6AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0f64KKKKDoCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/rgooooOgKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P+uCiiig6AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiq93cx2dtJdy/diUufooyaaV9EJuyuxl7qFjpsBudQmSCMdWkYKo/E4FUdL8RaDreTo97BdY6+VIr4/75Jr+UL9sL9qj4ifHb4k6nFc389voVpcSQWljG5WIIjFdzqMBmbGcnNfMXw7+LPxC+E3iGDxN4A1WfTbqBw48pyEbB6OmdrA9wRX9L5f9G/E1cEq9XEKNRq/La6Xk3f77L7z8KxPjfQjinSp0W6adr319Urfr9x/bnRX5K+F/+CuHwCj8CaXe+MFvRrb26fbLe3gLKkwGHCseCM8iuS8Qf8FnPgzYIf7E8N6pdsP75jjH6sa/K4+E/EMpuEcLLR27L721ofpC48ynlUvbrU/ZeivwF8Qf8FtXQMvh3wQCexuLrH/oCmvFNd/4LV/HW6U/2D4b0qzOON7STY/PbXt4bwL4kqb0VH1lH9GzCXiDlf2Zt+iZ+nH7a3/BSLwH+ypfDwRoNkPEPil0DtaiTy4bdT0MzgEgnsoGT7V+YWhf8Fvvjbb64k3iTwrpFzpxf5ooGmil255xIzOMgeq/lX5JfFL4i+Jfiz4+1T4jeL5BJqOrztPMVBC5PACgk4AHAFeZP2r+kuG/BHJcNgo0sZSVSo170m3v1tZqyXTqfGYjjDF1qzlSlyx6Ly8z+4/9l39qb4bftXfD4eOfAEjRvC3lXlnNgTW0uM7XAJBBHKsOCK+la/kh/wCCUn7S/gb9nv4yavH8UNYGk6JrVisW+QMYvtMcgMZbHC/Kzcmv6rvB/wAQfBHxA01NY8Eara6rbSDKyW0qyDB/3Tx171/LPifwLLJcynSoxfsXZxbTtr0vs7H6dkeafWaClN+91Owooor80PaCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//1P64KKKKDoCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKK5Lxr488G/DnQZfE/jrUoNLsIfvzXDhFz2A7knsACT6V8lWX/BRn9ka91YaSvicJubYJXglWLOcZ3bcge5Fezl3DmYYyDqYShKcVu4xbX4I8rHZ7gsLJQxNWMW+jaX5n3FRXP6Z4r8M6zoMfinSdQt7jTZU8xLpJFMRX13524/GvkD4wf8FB/2a/hIJbJtYGuahHkfZtNAm5HZpPuD8CfpSyzh/HY2r7DCUZTl2Senr2+Y8wzvB4Sn7bE1VGPdvf07/I+365bxV438IeB9PbVfGGp22mW6DJkuJFjH4ZOT+Ffz7/GL/grJ8X/Fgl0z4W2MHh21fIEzfv7nH+83yqcegz71+anjb4mfED4kak+r+OtWutUnkOS1xIz85zwCcCv3Hhv6O2Y4i08xqKkuy96X+S+9+h+R5744YGjeGBg6j7vRf5v7kf0M/GD/AIKpfArwP5un/D+ObxNeJkB4h5dvkd97ckfQV+fPiX9rr9t39qieXRfhpYz6fpk2UZNOjKIFPBEly+B09xXwT8ONN8Z312g8DeGm1q9JwjC1e6x9EwUBHY44r7s0D9lj/goJ8YLNbfVhcaPpzgBUu7hbaML7QxZI+hUV+p0+BeHsgSl+7519qtK7+UNF+R+dz4vzrOW4+/yv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OPWv5g/2ZP8Ag1l/aF+BP7RHgn4z6r8TNCvbXwvrVnqk1vFZ3CvKltKsjIpMmASBgE1/bpRQDVwooooGfmh+3r/wSa/Y3/4KHaSJPjZ4eFv4hgj8u117TiLfUIR2BkAxKg/uSBl9q/lZ+Ov/AAaL/HrS9SmuP2c/iVo+s2ZJMUGuwy2UyjsGlt1mRj7iNfpX96tFAnFH+cDo3/Bqb/wUu1DVDZ6lqPg2xgU8ztqVy4I9VVbTJ+hxX6pfsr/8Gk/gDw3qlt4g/a28fy+IkiZXfStEiNpA+MEo9w7NKy/7gQ1/ZZRQJQR4r8BP2dvgt+zD8O7P4VfAnw7Z+G9DsVCx29nGEDHu7t953PUsxJJ6mvaqKKCgooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKt7Y2epWr2OoRJPDKCrpIoZWB6gg8EV8t6v+wx+yBruu/8JJqvw60Ka8LF2drOP5mPdhjBP1r6uorswmY4jD39hUcb9m1+RcKko/C7GD4b8LeG/B2kxaF4UsYNOsoRtjgt41jRR6BVAFb1FFcs5uT5pPUhsjliWaNon6MCDjjrXxp4D/4J/fsrfDf4sL8bfCnhvyvEiSyzrdSXE0uJZs732SOy7uTg447V9n0V2YTM8RQjKFCo4qSs7Nq67PuaU604JqLtcKKKK4TMKKKKACiiigAooooAKKKKACiiigAooooA/9T+uCiiig6AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1f64KKKKDoCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKK/Bz/grl/wWxsP+CWfxB8JeBbzwJJ4tPimyubwSpeC28n7O6JtwY33Z35zxjFdT/wSW/4LWfC3/gqFe+IvCEOgN4O8T6CEnTTprlbg3Nq3BljYKn3G4ZcHHXpQ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obhAwHupPKn3HNfix8Zv+CD3wa8UXcmqfBvxJeeG3cki1uFF3bjPOFyVkH/fR+lcHBHEHDf9n/2dnFKzu3zWvv5r3lpbyMspxmB9j7DFR+f9ao9n8L/8Ftv2N9ZtPO1ttV0yUAZjktt/5FWwa8o+NX/BdT4FeHtAuoPgxpF7rmqsjLA90ggt1bnDPyWYZ7DFfCGrf8EGP2j7adk0fxNol1HnhpPOiJHrja38667wT/wQL+Ld9ep/wn/jTTrC3GNws4ZJ3PqAXKAfXFfTQyDgSlL28sQ2u12/wSud8cHk8Xzud/L+lc/E7Ubz4iftDfF241OWOXV/EvizUXmZYly81zdSFiFUdOT9APav7tf2O/gb/wAM4fs2eFPg/OQ11pdmDdsvQ3MzGWbHqA7lQfQCvHP2SP8AgnJ+zz+yIy654RtJNW8QlNjatf7ZJwD1EQACxg/7IBPevvuvkPFDxFpZsqeDwUbUYa66XdrLToktv0PN4gzuOJtSpK0UFFFFfj58yFFFFABRRRQAUUUUAFFFFAH/0f64KKKKDoCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/rgooooOgKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P+uCiiig6AooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P64KKKKDoCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/rgooooOgKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9k=) <br>
**Statistical and Descriptive Analytics** <br>
*Social Media Interaction Analysis During Mexican 2024 Presidential Campaign* <br>
Tuesday, november 26th, 2024 <br>
Team 5 in collaboration with [Observatorio de Medios Digitales](https://sites.google.com/tec.mx/observatorio-medios-digitales/inicio?authuser=0)

# Target Hypothesis
Social media engagement metrics, including interaction share, like count, and comment count, closely track shifts in voting intentions for each candidate throughout the election period. This analysis will evaluate the correlation between these metrics and voting intentions, testing for statistical significance to determine if these metrics reflect changes in public support as indicated by polling data.

# Exploratory Data Analysis Methodology
Our **first approach** on this task (see *libraries, dictionaries and function definitions* section) was to prepare all the information we were going to need for the analysis and hypothesis testing. After having defined the hypothesis, we imported all the necessary libraries, declared all the necessary dictionaries (things like color maps, path directories and other aesthetic details for the plots), and defined all necessary functions to work around with the data on this initial Exploratory Data Analysis. <br>
<br> **Secondly**, we moved on to loading the data and aquiring initial descriptions on it to give us a quick glanse and ensure that everything was imported correctly (see *Loading the data* section). <br>
<br> **Thirdly** we started pre-processing the data by using a function that formats the date column as a datetime object for better handling. This function also cuts the incorrect dates for us, fully cleaning and formatting the date column for us. On the same step, we proceed to handle **missing and duplicated data** by removing missing values, dropping the second duplicated URLs and joining together the cases in which 2 or more candidates are mentioned in the same post. A time delta of -6 hours was used to correct the datetime column as inconsistencies were found along the dataset due to the geotime location used upon gathering the data (see *Cleaning the dataset*). <br>
<br> **The fourth step** was to do the main part of the EDA with our hypothesis in mind, steps like **visualizing the distribution** of the number of interactions, likes and comments were crucial to the EDA. Moreover, we gathered official voting intentions data (from different registered pollsters) since January 10th, 2024(which was the day that the candidate Álvarez Máynez officially entered the race) until May 29th, 2024, which was the last official presidential campaign day (see *Exploratory Data Analysis* for more). <br>
<br> **The fifth and final step** was to test the gathered and clean data against our hypothesis using techniques like **correlation matrices** and **regression tests** to further understand if the different engagement metrics actually have a relationship with voting intentions and the final official registered vote for the three candidates.

## Libraries, dictionaries and function definitions
We import different libraries, assing different color and other miscellaneus dictionaries, as well as define different functions that all will be useful to estandarize templates and activities throughout the notebook.

### Libraries
Python library importing for future use along the notebook.
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
from PIL import Image
import plotly.express as px
import plotly.io as pio
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import timedelta
from scipy.stats import pearsonr, spearmanr
import itertools
import statsmodels.api as sm


"""### Dictionaries
Definition of data paths, color and other miscellaneus dictionaries for future reference within the notebook.
"""

# Setting the base path and directories
base_path = '/Users/racoin/Downloads/Visual Studio/DashboardVS/DA_Template/ALL'  # Change the desired directory

files = {
    'X': [
        '/x/infotracer-x-enero-24.csv',
        '/x/infotracer-x-febrero-24.csv',
        '/x/infotracer-x-marzo-24.csv',
        '/x/infotracer-x-abril-24.csv',
        '/x/infotracer-x-mayo-24.csv',
        '/x/infotracer-x-junio-24.csv',
        '/x/infotracer-x-julio-24.csv'
    ],
    'Facebook': [
        '/fb/infotracer-facebook-enero-24.csv',
        '/fb/infotracer-facebook-febrero-24.csv',
        '/fb/infotracer-facebook-marzo-24.csv',
        '/fb/infotracer-facebook-abril-24.csv',
        '/fb/infotracer-facebook-mayo-24.csv',
        '/fb/infotracer-facebook-junio-24.csv',
        '/fb/infotracer-facebook-julio-24.csv'
    ],
    'Youtube': [
        '/you/infotracer-youtube-enero-24.csv',
        '/you/infotracer-youtube-febrero-24.csv',
        '/you/infotracer-youtube-marzo-24.csv',
        '/you/infotracer-youtube-abril-24.csv',
        '/you/infotracer-youtube-mayo-24.csv',
        '/you/infotracer-youtube-junio-24.csv',
        '/you/infotracer-youtube-julio-24.csv'
    ],
    'Instagram': [
        '/ig/infotracer-instagram-enero-24.csv',
        '/ig/infotracer-instagram-febrero-24.csv',
        '/ig/infotracer-instagram-marzo-24.csv',
        '/ig/infotracer-instagram-abril-24.csv',
        '/ig/infotracer-instagram-mayo-24.csv',
        '/ig/infotracer-instagram-junio-24.csv',
        '/ig/infotracer-instagram-julio-24.csv'
    ]
}

"""Importing company's logo (this has to be done prior to function definition becuase it is defined as a base parameter for the functions)."""

# Import company's logo
# Saves the image to a variable
logo = Image.open(base_path + '/OMD.png')

# Estandarize image size for all graphics
logo = logo.resize(tuple((np.array(logo.size) * 0.7).astype(int)))

# Visualize the logo and its size.
logo

"""Graphs, colors, and miscellaneus."""

color_map = {
    'voting': 'black',
    'x': '#1DA1F2',
    'youtube': '#FF0000',
    'facebook': '#4267b2',
    'instagram': '#E1306C',
}

candidate_plot_colors = {
    'claudia': '#741D23',
    'maynez': '#FF8300',
    'xochitl': '#1E75BC'
}

# Fallback colors if no match
fallback_colors = ['#92E03B', '#FF5733', '#33A7FF', '#FFC300', '#8E44AD']
color_cycle = itertools.cycle(fallback_colors)

# Define a color map for candidates
colors = {
    'Claudia Sheinbaum': '#741D23',
    'Jorge Álvarez Máynez': '#FF8300',
    'Xóchitl Gálvez': '#1E75BC'
}

# Diccionario para guardar los colores de acuerdo al cliente (EDITAR)
colores = {
    "main": "#3958AA",
    "secondary": "#353434",
    "tert": "#B1013F",
    "cuart": "#5CB601",
    "quint": "#CA9401",
}
# Diccionario para argumentos del TITULO SUPERIOR
suptitle_dict = {
    "size": 22,
    "x": 0.35,
    "y": 1.04,
    "weight":"bold",
    "ha": "left",
    "color": colores["main"]
}

# Diccionario para argumentos de title
title_dict = {
    "size": 13,
    "x": 0.28,
    "y": 1.0,
    "ha": "left",
    "color": colores["secondary"]
}

"""### Functions

##### Data Handling Functions
"""
st.header("Exploratory Data Analysis")

###### --------------------------------------------------------------------DATA HANDLING-------------------------------------------------------------------- ######

# Load data function
def load_data(path, filesDict):
  '''
  This function will help us load our multiple csv into a single dataframe.
  path: path to the csv files
  filesDict: dictionary of platform and file names
  '''
  df= pd.DataFrame()
  for platform, file_list in filesDict.items():
    for file_name in file_list:
      temp_df= pd.read_csv(path + file_name)
      temp_df['platform']= platform
      df= pd.concat([df, temp_df], ignore_index=True)
  return df

# Function to filter per date
def selectDataByDate(df, start_date, end_date):
    """
    Selects data from a dataframe between two dates.
    df: (DataFrame)
      Dataframe with a column named 'datetime'.
      start_date: (str)
        Start date in the format 'YYYY-MM-DD'.
      end_date: (str)
        End date in the format 'YYYY-MM-DD'.
    """
    # Convert the 'datetime' column to datetime format, ignoring invalid values
    df['datetime'] = pd.to_datetime(df['datetime'], errors='coerce')

    # Adjust the time to Mexico timezone by subtracting 6 hours
    df['datetime'] = df['datetime'] - timedelta(hours=6)

    # Check how many values were converted to NaT (invalid values)
    invalid_dates = df['datetime'].isna().sum()
    print(f"We found {invalid_dates} invalid values in the 'datetime' column.")

    # Check the range of valid dates
    valid_dates = df['datetime'].dropna()
    min_date = valid_dates.min()
    max_date = valid_dates.max()
    print(f"Range of valid dates: {min_date} to {max_date}")

    # Ensure that the provided date range overlaps with the data's date range
    if end_date < min_date or start_date > max_date:
        print("Warning: The specified date range does not overlap with the data's date range.")
        return pd.DataFrame()  # Return an empty DataFrame if there's no overlap

    # Filter the data within the specified date range
    filtered_df = df[(df['datetime'] >= start_date) & (df['datetime'] <= end_date)]
    print(f"Number of rows in the filtered DataFrame: {len(filtered_df)}")

    return filtered_df

"""##### Statistical Functions"""

#### ------------------------------------------------------------------ STATISTICS --------------------------------------------------------------------------- #####

# Function to calculate Pearson and Spearman correlations
def calculate_correlations(df, target_var):
    correlation_results = []

    # Loop through each column in the DataFrame, excluding the target variable
    for column in df.columns:
        if column != target_var and pd.api.types.is_numeric_dtype(df[column]):
            # Calculate Pearson and Spearman correlations
            pearson_corr = df[target_var].corr(df[column], method='pearson')
            spearman_corr = df[target_var].corr(df[column], method='spearman')

            # Append results to the list
            correlation_results.append({
                'Metric': column,
                'Pearson Correlation': pearson_corr,
                'Spearman Correlation': spearman_corr
            })

    # Convert list to DataFrame
    correlation_df = pd.DataFrame(correlation_results)

    # Filter for correlations with an absolute value greater than 0.5
    high_corr_df = correlation_df[(correlation_df['Pearson Correlation'].abs() > 0.5) |
                                  (correlation_df['Spearman Correlation'].abs() > 0.5)]

    # Sort by the absolute Pearson correlation
    high_corr_df = high_corr_df.sort_values(by='Pearson Correlation', key=np.abs, ascending=False)

    return high_corr_df


def simple_linear_regression(df, metric_column, voting_intention_column):
    """
    Perform a simple linear regression analysis.

    df: (DataFrame)
        The DataFrame containing the data.

    metric_column: (str)
        The name of the column representing the independent variable (X).

    voting_intention_column: (str)
        The name of the column representing the dependent variable (Y).

    Returns:
    model: (statsmodels.regression.linear_model.RegressionResultsWrapper)
        The fitted regression model.
    """
    # Define the independent (X) and dependent (Y) variables
    X = df[metric_column]
    Y = df[voting_intention_column]

    # Add a constant to the independent variable (for the intercept)
    X = sm.add_constant(X)

    # Fit the regression model
    model = sm.OLS(Y, X).fit()

    # Print the summary of the regression
    print(f"Regression analysis for {metric_column} predicting {voting_intention_column}")
    print(model.summary())

    # Return the model for further analysis if needed
    return model

"""##### Plotting Functions"""

##### --------------------------------------------------------------- PLOTING FUNCTIONS ---------------------------------------------------------------------- ######

# Updated client_template function with adjustable logo coordinates
def client_template(suptitle="This is the superior title",
                    title="This is a general description of plot",
                    suptitle_dict=suptitle_dict,
                    title_dict=title_dict,
                    logo=logo,
                    logo_x_coord=0.03,  # Default x-coordinate for the logo
                    logo_y_coord=0.94,   # Default y-coordinate for the logo
                    ):
    """
    Modifies the visuals of a graph to follow the company's template with adjustable logo coordinates.
    suptitle: (str) Superior title for the graph.
    title: (str) General title for the plot.
    suptitle_dict: (dict) Parameters for the superior title.
    title_dict: (dict) Parameters for the title.
    logo: (str) Path to the company's logo.
    logo_x_coord: (float) Horizontal positioning of the logo.
    logo_y_coord: (float) Vertical positioning of the logo.
    """

    # Get the values of the figure for automatic proportion images
    fig = plt.gcf()
    x, y = fig.get_size_inches() * fig.dpi

    # Set the suptitle
    plt.figtext(s=suptitle, x=suptitle_dict["x"] - 0.2, y=suptitle_dict["y"],
                fontsize=suptitle_dict["size"], weight=suptitle_dict["weight"],
                ha=suptitle_dict["ha"], color=suptitle_dict["color"])

    # Set the title
    plt.figtext(s=title, x=title_dict["x"] - 0.13, y=title_dict["y"],
                fontsize=title_dict["size"], ha=title_dict["ha"],
                color=title_dict["color"])

    # Adjust the logo placement (using x and y coordinates)
    plt.figimage(logo, logo_x_coord * x, logo_y_coord * y, zorder=3)

    # Adjust the layout to avoid overlap
    plt.tight_layout()

# Define the desired order for the candidates
candidate_order = ['Claudia Sheinbaum', 'Xóchitl Gálvez', 'Jorge Álvarez Máynez']

# Ensure the 'candidate_name' column is in the specified order
def prepare_data(df):
  """
  Re-orders candidate names for visualizaiton purposes
  """
  df['candidate_name'] = pd.Categorical(df['candidate_name'], categories=candidate_order, ordered=True)
  return df.sort_values('candidate_name')

def plot_client_template_piechart(df, column_name, suptitle, title, suptitle_dict, title_dict, logo, color_map, logo_x_coord=0.03, logo_y_coord=0.94, label_fontsize=14):
    """
    Creates a pie chart based on the value counts of a specific column, following the client's template, and applies a custom color map.

    Parameters:
    df (DataFrame): DataFrame containing the data to plot.
    column_name (str): The column name for which value counts are plotted.
    suptitle (str): The superior title of the pie chart.
    title (str): The general description of the pie chart.
    suptitle_dict (dict): Dictionary with parameters for the superior title.
    title_dict (dict): Dictionary with parameters for the title.
    logo (str): Path to the company logo.
    color_map (dict): Dictionary mapping unique labels to colors.
    logo_x_coord (float): Horizontal positioning of the logo.
    logo_y_coord (float): Vertical positioning of the logo.
    label_fontsize (int): Font size for the percentage labels inside the pie chart.
    """
    # Calculate value counts
    value_counts = df[column_name].value_counts()
    unique_labels = value_counts.index

    # Apply colors based on color_map; default to 'gray' if label is missing in color_map
    colors = [color_map.get(label, 'gray') for label in unique_labels]

    # Create the pie chart
    plt.figure(figsize=(8, 8))  # Adjust figure size as needed
    plt.pie(value_counts, labels=unique_labels, autopct='%1.1f%%', startangle=90,
            wedgeprops={'edgecolor': 'white'}, colors=colors, textprops={'fontsize': label_fontsize})

    # Apply the client template for consistent branding
    client_template(suptitle=suptitle, title=title,
                    suptitle_dict=suptitle_dict, title_dict=title_dict,
                    logo=logo, logo_x_coord=logo_x_coord, logo_y_coord=logo_y_coord)

    # Display the plot
    plt.show()


def plot_2x2_barchart(df, suptitle, suptitle_dict, title_dict, logo, color_map, logo_x_coord=0.03, logo_y_coord=0.94):
    """
    Creates a 2x2 bar chart to compare metrics (sum, mean, median, std) for each candidate with y-label in millions for 'sum'.

    Parameters:
    df (DataFrame): DataFrame containing aggregated interaction metrics for candidates.
    suptitle (str): The superior title of the chart.
    suptitle_dict (dict): Dictionary with parameters for the superior title.
    title_dict (dict): Dictionary with parameters for the subtitle.
    logo (str): Path to the company logo.
    color_map (dict): Dictionary mapping each candidate to a specific color.
    logo_x_coord (float): Horizontal positioning of the logo.
    logo_y_coord (float): Vertical positioning of the logo.
    """
    metrics = ['sum', 'mean', 'median', 'std']
    candidates = df.index.tolist()
    values = [df[('num_interaction', metric)].tolist() for metric in metrics]

    fig, axs = plt.subplots(2, 2, figsize=(12, 10))
    fig.subplots_adjust(hspace=0.4, wspace=0.4)

    # Iterate over each metric to plot in the 2x2 layout
    for i, metric in enumerate(metrics):
        ax = axs[i // 2, i % 2]
        metric_values = values[i]

        # Adjust 'sum' values to be in millions for display
        if metric == 'sum':
            metric_values = [value / 1_000_000 for value in metric_values]  # Convert to millions
            ylabel = "Sum (in millions)"
        else:
            ylabel = metric.capitalize()

        # Plot each candidate's value for the current metric
        for j, candidate in enumerate(candidates):
            ax.bar(candidate, metric_values[j], color=color_map.get(candidate, 'gray'))

        # Set title and labels for each subplot
        ax.set_title(f"{metric.capitalize()} of Interactions", fontsize=14)
        ax.set_xlabel('Candidate')
        ax.set_ylabel(ylabel)

    # Apply client template for overall title, logo, and subtitle
    client_template(suptitle=suptitle,
                    title="Comparison of Interaction Metrics by Candidate",
                    suptitle_dict=suptitle_dict,
                    title_dict=title_dict,
                    logo=logo,
                    logo_x_coord=logo_x_coord,
                    logo_y_coord=logo_y_coord)

    # Show the plot
    plt.show()



def plot_youtube_metrics(youtube_df, suptitle, suptitle_dict, title_dict, logo, logo_x_coord=0.03, logo_y_coord=1):
  """
  Plots a 2x2 grid of bar charts showing YouTube metrics for each candidate.
  youtube_df: (DataFrame)
    DataFrame containing YouTube metrics for different candidates.
  All of the other parameters are explained before.
  """
  youtube_df = prepare_data(youtube_df)
  metrics = ['interaction_share', 'likes_share', 'comments_share', 'views_share']
  titles = ['Interaction Share', 'Likes Share', 'Comments Share', 'Views Share']

  fig, axs = plt.subplots(2, 2, figsize=(12, 10))
  fig.subplots_adjust(hspace=0.4, wspace=0.4)

  for i, metric in enumerate(metrics):
      ax = axs[i // 2, i % 2]
      ax.bar(youtube_df['candidate_name'], youtube_df[metric], color=[colors[c] for c in youtube_df['candidate_name']])
      ax.set_title(titles[i])
      ax.set_xlabel('Candidate')
      ax.set_ylabel(f'{titles[i]} (%)')

  client_template(suptitle=suptitle, title="YouTube Metrics Comparison", suptitle_dict=suptitle_dict,
                  title_dict=title_dict, logo=logo, logo_x_coord=logo_x_coord, logo_y_coord=logo_y_coord)

  plt.show()


# Function to plot the 1x3 grid for other platforms' metrics
def plot_platform_metrics(platform_df, platform_name, suptitle, suptitle_dict, title_dict, logo, logo_x_coord=0.03, logo_y_coord=0.99):
  """
  Plots a 1x3 grid of bar charts showing platform metrics for each candidate.
  platform_df: (DataFrame)
    DataFrame containing platform metrics for different candidates.
  """
  platform_df = prepare_data(platform_df)
  metrics = ['interaction_share', 'likes_share', 'comments_share']
  titles = ['Interaction Share', 'Likes Share', 'Comments Share']

  fig, axs = plt.subplots(1, 3, figsize=(15, 5))
  fig.subplots_adjust(wspace=0.4)

  for i, metric in enumerate(metrics):
      ax = axs[i]
      ax.bar(platform_df['candidate_name'], platform_df[metric], color=[colors[c] for c in platform_df['candidate_name']])
      ax.set_title(titles[i])
      ax.set_xlabel('Candidate')
      ax.set_ylabel(f'{titles[i]} (%)')

  client_template(suptitle=suptitle, title=f"{platform_name} Metrics Comparison", suptitle_dict=suptitle_dict,
                  title_dict=title_dict, logo=logo, logo_x_coord=logo_x_coord, logo_y_coord=logo_y_coord)

  plt.show()


# Define the function to plot the pie charts with adjusted logo coordinates and label sizes
def plot_interaction_share_2x2(platforms_to_plot, data, logo, suptitle="Interaction Share Per Platform", label_fontsize=12, autotext_fontsize=12):
    """
    Plots a 2x2 grid of pie charts showing interaction share for each platform.

    Parameters:
    platforms_to_plot: (list) List of platforms to generate the pie charts.
    data: (DataFrame) DataFrame containing interaction shares for different platforms.
    logo: Path to the logo image file.
    suptitle: (str) Title of the plot.
    label_fontsize: (int) Font size for the labels around the pie chart.
    autotext_fontsize: (int) Font size for the percentage labels inside the pie chart.
    """
    fig, axs = plt.subplots(2, 2, figsize=(12, 12))
    axs = axs.flatten()

    for i, platform in enumerate(platforms_to_plot):
        # Filter the data for the selected platform
        platform_data = data[data['platform'] == platform]

        # Prepare the pie chart in the corresponding subplot
        wedges, texts, autotexts = axs[i].pie(
            platform_data['interaction_share'],
            labels=platform_data['candidate_name'],
            autopct='%1.1f%%',
            colors=[colors[candidate] for candidate in platform_data['candidate_name']],
            startangle=140
        )

        axs[i].set_title(f'Interaction Share for {platform}', fontweight = 'bold')

        # Set the font size for labels (around the pie chart)
        for text in texts:
            text.set_fontsize(label_fontsize)

        # Set the font size for percentage labels (inside the pie chart)
        for autotext in autotexts:
            autotext.set_color('white')
            autotext.set_fontsize(autotext_fontsize)

    # Adjust the logo coordinates
    x, y = fig.get_size_inches() * fig.dpi
    logo_x_coord = x * 0.03  # Adjust horizontal positioning
    logo_y_coord = y * 0.88  # Adjust vertical positioning

    plt.figimage(logo, logo_x_coord, logo_y_coord, zorder=3)  # Manually place the logo

    # Add a suptitle to the entire figure
    plt.suptitle(suptitle, fontsize=16, fontweight='bold')

    plt.tight_layout()
    plt.show()


def plot_candidate_metrics(df, candidate_name, voting_col, interaction_share_col):
    """
    Plot voting intention and num_interaction share for a given candidate.

    df: (DataFrame) The final dataframe with pollster and interaction data.
    candidate_name: (str) Name of the candidate.
    voting_col: (str) The column for voting intention.
    interaction_share_col: (str) The column for interaction share.
    """
    fig, ax1 = plt.subplots(figsize=(10, 6))

    # Plot voting intention on the left y-axis
    ax1.set_xlabel('Date')
    ax1.set_ylabel(f'{candidate_name} Voting Intention (%)', color='tab:blue')
    ax1.plot(df['date'], df[voting_col], color='tab:blue', label=f'{candidate_name} Voting Intention')
    ax1.tick_params(axis='y', labelcolor='tab:blue')

    # Create a second y-axis for the interaction share
    ax2 = ax1.twinx()
    ax2.set_ylabel(f'{candidate_name} Interaction Share (%)', color='tab:orange')
    ax2.plot(df['date'], df[interaction_share_col], color='tab:orange', linestyle='--', label=f'{candidate_name} Interaction Share')
    ax2.tick_params(axis='y', labelcolor='tab:orange')

    # Titles and layout
    plt.title(f'{candidate_name} - Voting Intention vs Interaction Share Over Time')
    fig.tight_layout()
    plt.show()

def plot_client_template_lineplot(df, x_col, y_cols, labels, suptitle, title, logo_x_coord=0.03, logo_y_coord=0.98, color_map=color_map):
    """
    Plots multiple line plots on the same figure using the client's template.

    Parameters:
    df (DataFrame): DataFrame containing the data to plot.
    x_col (str): The column name to use for the x-axis (e.g., 'date').
    y_cols (list): A list of column names for the y-axes (e.g., ['num_interaction_share', 'voting_intention']).
    labels (list): A list of labels for each y-axis column (e.g., ['Num Interaction Share', 'Voting Intention']).
    suptitle (str): The title to be placed at the top of the plot.
    title (str): The subtitle to be placed below the suptitle.
    color_map (dict): Dictionary mapping general labels to colors.
    """
    # Create the plot
    plt.figure(figsize=(10, 6))

    # Plot each line specified in y_cols
    for y_col, label in zip(y_cols, labels):
        # Normalize label to lowercase for case-insensitive matching
        label_lower = label.lower()

        # Determine color based on platform, voting, or candidate rules
        color = None

        # Check for platform or "voting" keyword in label
        platform_key = next((key for key in color_map.keys() if key in label_lower), None)
        if platform_key:
            color = color_map[platform_key]
        elif 'voting' in label_lower:
            color = color_map['voting']
        else:
            # Check candidate colors if platform and voting keywords are not found
            candidate_key = next((key for key in candidate_plot_colors.keys() if key in label_lower), None)
            color = candidate_plot_colors.get(candidate_key, next(color_cycle))  # Use fallback if no match

        # Plot with selected color
        sns.lineplot(data=df, x=x_col, y=y_col, label=label, color=color)

    # Set labels for the axes
    plt.xlabel('Date', fontsize=12)
    plt.ylabel('Value', fontsize=12)

    # Apply the client's template
    client_template(
        suptitle=suptitle,
        title=title,
        suptitle_dict=suptitle_dict,
        title_dict=title_dict,
        logo=logo,
        logo_x_coord=logo_x_coord,
        logo_y_coord=logo_y_coord
    )

    # Show the plot
    plt.show()


# Updated correlation matrix function with adjustable logo coordinates
def plot_correlation_matrix(data, candidate_name, logo, suptitle_dict, title_dict, logo_x_coord=0.03, logo_y_coord=0.94, annot_fontsize=12):
    """
    Generates a correlation matrix and heatmap for a given candidate's metrics with the company's template.

    data: DataFrame
        The dataframe containing metrics.
    candidate_name: str
        Name of the candidate (e.g., "claudia", "xochitl", "maynez").
    logo: Image
        Company's logo to display on the plot.
    suptitle_dict: dict
        Dictionary of styling options for the suptitle.
    title_dict: dict
        Dictionary of styling options for the title.
    logo_x_coord: float
        The x-coordinate for placing the logo.
    logo_y_coord: float
        The y-coordinate for placing the logo.
    annot_fontsize: int
        Font size for the annotations inside the heatmap.
    """
    # Extract the relevant columns for the candidate
    columns = [
        f'{candidate_name}_voting_intention',
        f'{candidate_name}_num_interaction_share',
        f'{candidate_name}_like_count_share',
        f'{candidate_name}_comment_count_share',
        f'{candidate_name}_view_count_share'
    ]

    # Compute correlation matrix
    corr_matrix = data[columns].corr()

    # Set up the figure and plot
    plt.figure(figsize=(10, 8))

    # Create heatmap with adjustable annotation font size
    sns.heatmap(corr_matrix, annot=True, annot_kws={"size": annot_fontsize}, cmap='coolwarm', cbar_kws={'shrink': .8})

    # Apply the company's template with adjustable logo coordinates
    client_template(
        suptitle=f"{candidate_name.capitalize()}'s Metrics Correlation Matrix",
        title="Correlation of voting intention with engagement metrics",
        suptitle_dict=suptitle_dict,
        title_dict=title_dict,
        logo=logo,
        logo_x_coord=logo_x_coord,  # Allow manual adjustment of x coordinate
        logo_y_coord=logo_y_coord   # Allow manual adjustment of y coordinate
    )

    # Display the plot
    plt.show()


# Correlation per chosen platform and candidate matrix
# Updated correlation matrix function with adjustable logo coordinates
def plot_platform_correlation_matrix(data, candidate_name, platform, logo, suptitle_dict, title_dict, logo_x_coord=0.03, logo_y_coord=0.94, annot_fontsize=12):
    """
    Generates a correlation matrix and heatmap for a given candidate's metrics per platform with the company's template.

    data: DataFrame
        The dataframe containing metrics.
    candidate_name: str
        Name of the candidate (e.g., "claudia", "xochitl", "maynez").
    platform: str
        The platform to filter the columns (e.g., "facebook", "instagram", "youtube", "x").
    logo: Image
        Company's logo to display on the plot.
    suptitle_dict: dict
        Dictionary of styling options for the suptitle.
    title_dict: dict
        Dictionary of styling options for the title.
    logo_x_coord: float
        The x-coordinate for placing the logo.
    logo_y_coord: float
        The y-coordinate for placing the logo.
    annot_fontsize: int
        Font size for the annotations inside the heatmap.
    """
    # Dynamically generate the columns for the selected candidate and platform
    if platform == 'youtube':
      columns = [
        f'{candidate_name}_voting_intention', # Always include voting intention
        f'{candidate_name}_{platform}_num_interaction_share',
        f'{candidate_name}_{platform}_like_count_share',
        f'{candidate_name}_{platform}_comment_count_share',
        f'{candidate_name}_{platform}_view_count_share'
    ]
    else:
      columns = [
        f'{candidate_name}_voting_intention', # Always include voting intention
        f'{candidate_name}_{platform}_num_interaction_share',
        f'{candidate_name}_{platform}_like_count_share',
        f'{candidate_name}_{platform}_comment_count_share',
    ]

    # Compute correlation matrix
    corr_matrix = data[columns].corr()

    # Set up the figure and plot
    plt.figure(figsize=(10, 8))

    # Create heatmap with adjustable annotation font size
    sns.heatmap(corr_matrix, annot=True, annot_kws={"size": annot_fontsize}, cmap='coolwarm', cbar_kws={'shrink': .8})

    # Apply the company's template with adjustable logo coordinates
    client_template(
        suptitle=f"{candidate_name.capitalize()} on {platform.capitalize()}: Metrics Correlation Matrix",
        title=f"Correlation of {candidate_name.capitalize()}'s voting intention with {platform.capitalize()} engagement metrics",
        suptitle_dict=suptitle_dict,
        title_dict=title_dict,
        logo=logo,
        logo_x_coord=logo_x_coord,  # Allow manual adjustment of x coordinate
        logo_y_coord=logo_y_coord   # Allow manual adjustment of y coordinate
    )

    # Display the plot
    plt.show()

# Correlation matrix function for num_interaction share across all platforms with voting intention
def plot_candidate_num_interaction_correlation(data, candidate_name, logo, suptitle_dict, title_dict, logo_x_coord=0.03, logo_y_coord=0.94, annot_fontsize=12):
    """
    Generates a correlation matrix and heatmap comparing a candidate's num_interaction share across all platforms with voting intention.

    data: DataFrame
        The dataframe containing metrics.
    candidate_name: str
        Name of the candidate (e.g., "claudia", "xochitl", "maynez").
    logo: Image
        Company's logo to display on the plot.
    suptitle_dict: dict
        Dictionary of styling options for the suptitle.
    title_dict: dict
        Dictionary of styling options for the title.
    logo_x_coord: float
        The x-coordinate for placing the logo.
    logo_y_coord: float
        The y-coordinate for placing the logo.
    annot_fontsize: int
        Font size for the annotations inside the heatmap.
    """
    # List of platforms to include
    platforms = ['facebook', 'instagram', 'youtube', 'x']

    # Dynamically generate the columns for num_interaction share across all platforms and voting intention
    columns = [f'{candidate_name}_{platform}_num_interaction_share' for platform in platforms]
    columns.append(f'{candidate_name}_voting_intention')  # Include voting intention for comparison

    # Compute correlation matrix
    corr_matrix = data[columns].corr()

    # Set up the figure and plot
    plt.figure(figsize=(10, 8))

    # Create heatmap with adjustable annotation font size
    sns.heatmap(corr_matrix, annot=True, annot_kws={"size": annot_fontsize}, cmap='coolwarm', cbar_kws={'shrink': .8})

    # Apply the company's template with adjustable logo coordinates
    client_template(
        suptitle=f"{candidate_name.capitalize()}'s Metrics Correlation Matrix Across Platforms",
        title="Correlation of voting intention with num_interaction share across platforms",
        suptitle_dict=suptitle_dict,
        title_dict=title_dict,
        logo=logo,
        logo_x_coord=logo_x_coord,  # Allow manual adjustment of x coordinate
        logo_y_coord=logo_y_coord   # Allow manual adjustment of y coordinate
    )

    # Display the plot
    plt.show()

"""## Loading the data
28 datasets (in .csv form) and 1 *mySentiPack.py* file were loaded onto Google Drive for easier and faster access through Google Colaboratory. Google Drive was set up and linked to Colab and then mySentiPack.py file was used to import and filter the data given our selected dates (we selected the entire dataset as an effort to leave it clean (see *cleaning the dataset* step) for future use in the predictive analytics project).
"""

df = load_data(base_path, files)
print(df.dtypes)
df.head()

"""Loading pollsters data"""

pollster_data = pd.read_csv(base_path + '/pollsters_data.csv') # Voting intentions collected from bloomberg's "Barometro Electoral 2024" up until may 28th, the data for june 2nd is the final official vote from the "PREP"

"""## Cleaning the dataset
To test the hypothesis that the average monthly number of interactions closely tracks real voting intentions, we began by carefully preparing and cleaning the dataset. The dataset initially contained several columns: ['date', 'candidate', 'platform', 'url', 'text', 'likes', 'comments', 'num_interactions']. Our first step was to remove duplicate entries to ensure that no redundant data would skew the analysis. Following that, we addressed any missing or null values by removing them from the dataset, ensuring that only complete records were retained. This rigorous data cleaning process ensured that the dataset was both accurate and consistent.

Initial dataset characteristics:
"""

print(f'Initial shape before any manipulation: {df.shape}')
print(f'Initial number of duplicates: {df.duplicated().sum()}')
print(f'Initial number of missing values:\n{df.isnull().sum()}')

"""### Filtering for date
Filtering and formatting date column with function.
"""

start_date = pd.to_datetime('2024-01-01 00:00:00')
end_date = pd.to_datetime('2024-07-31 23:59:59')
df = selectDataByDate(df, start_date, end_date)
df.dtypes

"""### Missing Values and Duplicates
As stated in **Methodology** section, missing and duplicated values were treated to ensure that missing values in the *text* column were dropped (as we can't impute text at will) but also to join together duplicated URLs were two or more candidates were being mentioned in the same post (URL) to ensure to duplicated posts appear on the following exploration (*Exploratory Data Analysis* section) and affect our findings.

#### URL Exploration
First we find the duplicated URLs and treat them by solving iterated questions: <br>
**Q:** How many duplicated rows are there and how much do they represent from the entire dataset?
"""

dup = df['url'].duplicated().sum()
print(f'Number of duplicated URLs: {dup} \nPercentage of total records: {round((dup / len(df["url"])) * 100, 2)}%')

"""**Q:** From those found duplicated values, how many interactions do those post contain? <br>
**Q:** How much do those interactions represent from the total number of interactions?
"""

q4 = df[df['url'].duplicated()]['num_interaction'].sum()
print(f'Number of interactions in duplicated URLs: {q4} \nPercentage of total interactions: {round((q4 / df["num_interaction"].sum()) * 100, 2)}%')

"""Duplicated rows may have a great impact on real number of interactions since they represent more than 10% of the total number of interaction, proving that handling them is important to ensure accurate and consistent data. But: <br>
**Q:** How does a duplicated URL look like? <br>
**Q:** Why do they appear?
"""

print('Example of duplicated rows: \n')
df[df["url"] == 'https://twitter.com/LCUgalde/status/1807803239443669301']

print('Duplicated text: \n')
df[df["url"] == 'https://twitter.com/LCUgalde/status/1807803239443669301']['text'].iloc[0]

"""It can be seen that we encounter duplicates when any given username's text is referring to 2 or more candidates. <br>
The company's post recopilation algorithm saves a post whenever a candidate (in the form of the candidate's official account username) is mentioned in a post. <br>
Given that functionality, everytime two or more candidates are mentioned in a single post, the recopilation tool sees and treats them as 2 independent posts, thus why we have so many duplicates.

#### URL Handling
On this step, we handle the duplicated URLs via the combination of those posts, dropping the second duplicated row and appending the name of the candidate that is mentioned in the second post, to the first post. This will result in a broader list of unique candidate names leftover in the *candidate* column.

Getting a new clean dataframe with no duplicated rows to which the clean (and joined) duplicated dataset will be joined.
"""

filtered_data = df.drop_duplicates(subset=['url','candidate_name'], keep = 'first')
filtered_data = df.groupby(['url'], as_index = False).agg({'candidate_name': lambda x: ', '.join(set(x))})

print("New list of unique cnadidate names: \n")
print(filtered_data['candidate_name'].unique())
print("\nNow the duplicated link that we saw before only has one instance and the two candidates it mentioned joined together via a comma as separator:\n")
filtered_data[filtered_data['url'] == 'https://twitter.com/LCUgalde/status/1807803239443669301']

"""Altering original df to make space for the new (merged) posts, while deleting the old (duplicated) ones."""

# Dropping duplicates and keeping only the first instances so the URLs are not lost:
before_rows = df.shape[0]
df.drop_duplicates('url', keep='first', inplace=True)

# Replacing candidates based on URLs

# Merging df and filtered_data
merged_df = df.merge(filtered_data, on='url', how='left', suffixes=('', '_filtered'))

# Updating candidate_name column
merged_df['candidate_name'] = merged_df['candidate_name_filtered'].combine_first(merged_df['candidate_name'])

# Dropping the _filtered column
merged_df.drop(columns=['candidate_name_filtered'], inplace=True)

print(f'New dataframe shape: {merged_df.shape}')
print(f'{before_rows - merged_df.shape[0]} duplicated rows joined together.')

pd.set_option('display.max_colwidth', None) # Tells pandas to not truncate the dataframe, used in this case to visualize the 'text' column completely.
print('Exploring the duplicated link before: \n')
merged_df[merged_df['url'] == 'https://twitter.com/LCUgalde/status/1807803239443669301'][['username','candidate_name','text']]

"""As it can be seen, the problematic URL explored before doesn't appear duplicated anymore and the two mentioned candidates are now joined together. <br>
Next step: Making merged_df copied to the df variable to ensure consistency throughout the code, merged_df was just a place holder. <br>
Dataframe was saved to a csv as a checkpoint if disconnected from session by Colab.
"""

df = merged_df.copy()
print(df['candidate_name'].unique())
df.shape
# CHECKPOINT
df.to_csv(base_path + '/all_together_no_duplicates.csv')
print("Checkpoint saved successfully")

df['candidate_name'].value_counts()

"""#### Missing Values Exploration
Following the same Q&A technique, we explore the missing values issue, starting with: <br>
**Q:** How many missing values does each column have? <br>
**Q:** What is their percentage related to the overall dataset?
"""

# Finding how many null values there are
null_val = df.isnull().sum() # Returns a pandas series
pd.DataFrame(null_val, columns=['Null Values']) # Transforming pandas series to a pandas DataFrame

# Calculating the percentage from entire dataset for all null values
null_val_perc = null_val / len(df) * 100
# Adding previously calculated percentages to the dataframe
null_val = pd.concat([null_val, null_val_perc], axis=1)
null_val.columns = ['Null Values', 'Null Values (%)'] # Setting column names

# Filtering to show only cases with missing values
null_val[null_val['Null Values'] > 0].sort_values(by='Null Values', ascending=False)

"""#### Missing Values Handling

The thumb rule for missing values is that if they represent less than 5% of the overall data, they can be eliminating without big reprecurssions. Moreover, given that we can't impute missing text values (string data tyeps can't be treated as numeric variables and impute the mean for example), these will be the first eliminated and further exploration will be made.
"""

# Dropping missing values in the 'text' column given that they represent less than 5% of the data.
df.dropna(subset=['text'], inplace=True)
df.isnull().sum()

"""That seemed to help for most of the missing data, given that we only have 1 missing value for 5 columns (possibly the same row), we are dropping based on those columns to ensure no more missing values are left in the dataset and we can move on to the rest of the EDA."""

df.dropna(subset = ['comment_count','view_count','like_count','url','num_interaction'], inplace = True)
df.isnull().sum()

"""Data is now clean and ready to be worked with in the *Exploratory Data Analytics* phase."""

df.to_csv(base_path + '/all_together_no_duplicates_no_missing.csv')
print("Checkpoint saved successfully")

"""#### Important note on metrics
It looks like there was a problem on the way some metrics were being collected, more specifically *like_count, comment_count and view_count* for the first 3 months (January, February and March), which is why this metrics can't be used for at least those 3 months.
"""

# Grouping the original dataset by month and calculating the sum of num_interactions
df['month'] = df['datetime'].dt.to_period('M')

# Group by month and calculate the sum of num_interaction
monthly_interactions = df.groupby('month').agg({
    'num_interaction': ['mean','sum'],
    'like_count': ['mean', 'sum'],
    'comment_count': ['mean', 'sum'],
    'view_count': ['mean', 'sum']
}).reset_index()

# Renaming columns for clarity
monthly_interactions.columns = ['month', 'mean_num_interaction', 'sum_num_interaction', 'mean_like_count', 'sum_like_count','mean_comment_count','sum_comment_count','mean_view_count','sum_view_count']

monthly_interactions

"""## Data Exploration
On this step, we further explore behaviours and relationships that can help us understand our data towards our hypothesis. <br>
First we start by checking the integrity of our dataframe after all of the hadndling:
"""

df.info()

"""#### Filtering dataset
On this step, we further filter the dataset to fit our scope of investigation (jan 10th to may 29th) and cases where the candidate is mentioned alone.
"""

df = df[(df['datetime'] >= '2024-01-10') & (df['datetime'] <= '2024-05-29')]
df.shape

"""Given that we don't really know to which candidate assign the duplicated values, and having multiple candidates doesn't track a single possible voter, we are going to ignore the ducplicated rows for the this task and the time being."""

unique_list = ['Xóchitl Gálvez', 'Claudia Sheinbaum', 'Jorge Álvarez Máynez']
df = df[df['candidate_name'].isin(unique_list)] # Filtering for rows in which the value in 'candidate_name' is found in the unique list provided
plot_client_template_piechart(df, 'candidate_name', 'Candidate Name Distribution', 'Distribution of Candidate Names in Dataset',
                               suptitle_dict, title_dict, logo, color_map=colors,
                              logo_y_coord=0.85,
                              logo_x_coord = 0.03)
print('\n')
print(df['candidate_name'].value_counts())

"""#### Descriptive Statistics"""

df.groupby('candidate_name').agg({'text' : 'count',
                                  'num_interaction': ['mean','sum'],
                                  'like_count':['mean','sum'],
                                  'comment_count':['mean','sum'],
                                  'view_count':['mean','sum']}).sort_values(by=('num_interaction', 'mean'), ascending=False)

"""It can be seen that candidate Claudia Sheinbaum is the leader in every metric among all platforms, during the entire time range. <br>
<br> **FINDING:** It's interesting to note how the mean number of interactions referring to Claudia Sheinbaum and Xóchitl Gálvez separately is almost identical, even though posts referring to Claudia Sheinbaum had much more total interactions. Let's further understand the *num_interaction* column:
"""

# Step 1: Aggregate and sort the DataFrame
df_aggregated = df.groupby('candidate_name').agg({
    'num_interaction': ['sum', 'mean', 'median', 'std']
})

# Step 2: Convert candidate_name to categorical with a custom order and sort
candidate_order = ['Claudia Sheinbaum', 'Xóchitl Gálvez', 'Jorge Álvarez Máynez']
df_aggregated = df_aggregated.reset_index()
df_aggregated['candidate_name'] = pd.Categorical(df_aggregated['candidate_name'], categories=candidate_order, ordered=True)
df_aggregated = df_aggregated.sort_values('candidate_name').set_index('candidate_name')

# Step 3: Now pass the ordered DataFrame to the plotting function
plot_2x2_barchart(df_aggregated,
                  suptitle="Candidate Interaction Metrics Comparison",
                  suptitle_dict=suptitle_dict,
                  title_dict=title_dict,
                  logo=logo,
                  color_map=colors,
                  logo_y_coord = 1,
                  logo_x_coord = .05)


df.groupby('candidate_name').agg({'num_interaction':['sum','mean','median','std']}).sort_values(by = ('num_interaction', 'mean'), ascending=False)

"""The median interactions (39 for Sheinbaum, 33 for Gálvez) and the standard deviation (higher for Sheinbaum at 2248) further show that Sheinbaum has more extreme outliers or highly popular posts, whereas Gálvez's posts are more consistent in interaction levels. Jorge Álvarez Máynez has far fewer interactions overall and per post (59 on average, with a median of 3), indicating a much smaller engagement compared to the other two candidates.

#### Descriptive statistics per platform and candidate
Grouping by candidate and platform to understand 3 different metrics: *num_interaction, like_count and comment_count* share in relation to the entire dataset. *view_count* was only taken in consideration for YouTube as that metric was only measured for that specific platform.
"""

# Grouping by candidate and platform to get sum of num_interactions, likes, and comments
grouped_df = df.groupby(['candidate_name', 'platform']).agg({
    'num_interaction': 'sum',
    'like_count': 'sum',
    'comment_count': 'sum',
    'view_count': 'sum'
}).reset_index()

# Calculating the total for each metric within each platform
platform_totals = df.groupby('platform').agg({
    'num_interaction': 'sum',
    'like_count': 'sum',
    'comment_count': 'sum',
    'view_count': 'sum'
}).reset_index()

# Merging the platform totals with the grouped data
grouped_df = grouped_df.merge(platform_totals, on='platform', suffixes=('', '_total'))

# Adding columns to show the share of each metric relative to each platform's total
grouped_df['interaction_share'] = (grouped_df['num_interaction'] / grouped_df['num_interaction_total']) * 100
grouped_df['likes_share'] = (grouped_df['like_count'] / grouped_df['like_count_total']) * 100
grouped_df['comments_share'] = (grouped_df['comment_count'] / grouped_df['comment_count_total']) * 100
grouped_df['views_share'] = (grouped_df['view_count'] / grouped_df['view_count_total']) * 100

# Rounding the values to 2 decimal places
grouped_df = grouped_df.round({
    'interaction_share': 2,
    'likes_share': 2,
    'comments_share': 2,
    'views_share': 2
})

"""#### Youtube share of metrics"""

# Displaying the results for Youtube only
youtube_df = grouped_df[grouped_df['platform'] == 'Youtube']

plot_youtube_metrics(
    youtube_df,
    suptitle="YouTube Candidate Metrics",
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo=logo,
    logo_x_coord = 0.04
)

print('YouTube metrics share per candidate: \n')
grouped_df[grouped_df['platform'] == 'Youtube'][['candidate_name','interaction_share','likes_share','comments_share','views_share']].sort_values(by='interaction_share', ascending=False)

"""#### X share of metrics"""

# Displaying the results for X only
x_df = grouped_df[grouped_df['platform'] == 'X']

# Plot for X metrics (1x3 grid)
plot_platform_metrics(
    x_df,
    platform_name="X",
    suptitle="X Candidate Metrics",
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo=logo,
    logo_y_coord = .97,
    logo_x_coord = .04
)


print('\nX metrics share per candidate: \n')
grouped_df[grouped_df['platform'] == 'X'][['candidate_name','interaction_share','likes_share','comments_share']].sort_values(by='interaction_share', ascending=False)

"""#### Facebook share of metrics"""

# Displaying the results for Facebook only
facebook_df = grouped_df[grouped_df['platform'] == 'Facebook']

# Plot for Facebook metrics (1x3 grid)
plot_platform_metrics(
    facebook_df,
    platform_name="Facebook",
    suptitle="Facebook Candidate Metrics",
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo=logo,
    logo_y_coord = .97,
    logo_x_coord = .04
)

print('\nFacebook metrics share per candidate: \n')
grouped_df[grouped_df['platform'] == 'Facebook'][['candidate_name','interaction_share','likes_share','comments_share']].sort_values(by='interaction_share', ascending=False)

"""#### Instagram share of metrics"""

# Displaying the results for Instagram only
instagram_df = grouped_df[grouped_df['platform'] == 'Instagram']

# Plot for Instagram metrics (1x3 grid)
plot_platform_metrics(
    instagram_df,
    platform_name="Instagram",
    suptitle="Instagram Candidate Metrics",
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo=logo,
    logo_y_coord = .97,
    logo_x_coord = .04
)

print('\nInstagram metrics share per candidate: \n')
grouped_df[grouped_df['platform'] == 'Instagram'][['candidate_name','interaction_share','likes_share','comments_share']].sort_values(by='interaction_share', ascending=False)

"""#### Interaction Metrics Visualization"""

# Selecting platforms to plot
platforms_to_plot = ['X', 'Facebook', 'Instagram', 'Youtube']
# Calling function
plot_interaction_share_2x2(platforms_to_plot, grouped_df, logo, label_fontsize=12, autotext_fontsize=12)

"""#### Understanding pollster data
Poll data up until May 28th was obtained from [Bloomberg's Barometo Electoral Webpage](https://www.bloomberg.com/graphics/2024-elecciones-mexico-encuestas-barometro-posicion-galvez-sin-cambios-pos-debate/), which made a "poll of polls" by averaging different official pollsters according to their proven trackrecord. <br>
The final date in the csv file (june 2nd) corresponds to the official final PREP count, obtained directly from the [Instituto Nacional Electoral's page](https://prep2024.ine.mx/publicacion/nacional/presidencia/nacional/candidatura)
"""

pollster_data['date'] = pd.to_datetime(pollster_data['date'])
print("CSV Info: \n")
print(pollster_data.info())
print('\n')
pollster_data.head()

"""In order to compare our data with the pollster's data, we need to ensure we have the aggregate (*cumulative*) metrics up to the date we are trying to compare the data with. <br>
E.g.: When trying to compare pollster's data from 2024-01-16, we would have to sum up the metrics for each of the candidates and then obtain their respective share *up to that date*. <br>
Which is what we do next:
"""

# Initialize an empty list to store the cumulative results
results = []

# Step 3: Loop through each row in the pollster_data to calculate cumulative metrics up to that date
for idx, row in pollster_data.iterrows():
    poll_date = row['date']

    # Filter the original df up to the current pollster date
    filtered_df = df[df['datetime'] <= poll_date]

    # Cumulative sum per candidate
    cum_metrics = filtered_df.groupby('candidate_name').agg({
        'num_interaction': 'sum',
        'like_count': 'sum',
        'comment_count': 'sum',
        'view_count': 'sum'
    }).reset_index()

    # Calculate the total cumulative values for all candidates combined
    total_cum_metrics = cum_metrics[['num_interaction', 'like_count', 'comment_count', 'view_count']].sum()

    # Calculate the share for each candidate relative to the total cumulative metrics
    cum_metrics['num_interaction_share'] = cum_metrics['num_interaction'] / total_cum_metrics['num_interaction'] * 100
    cum_metrics['like_count_share'] = cum_metrics['like_count'] / total_cum_metrics['like_count'] * 100
    cum_metrics['comment_count_share'] = cum_metrics['comment_count'] / total_cum_metrics['comment_count'] * 100
    cum_metrics['view_count_share'] = cum_metrics['view_count'] / total_cum_metrics['view_count'] * 100

    # Initialize default values in case a candidate is not found
    claudia_metrics = xochitl_metrics = maynez_metrics = {
        'num_interaction_share': 0,
        'like_count_share': 0,
        'comment_count_share': 0,
        'view_count_share': 0
    }

    # Safely extract data for each candidate if present
    if 'Claudia Sheinbaum' in cum_metrics['candidate_name'].values:
        claudia_metrics = cum_metrics[cum_metrics['candidate_name'] == 'Claudia Sheinbaum'].iloc[0]

    if 'Xóchitl Gálvez' in cum_metrics['candidate_name'].values:
        xochitl_metrics = cum_metrics[cum_metrics['candidate_name'] == 'Xóchitl Gálvez'].iloc[0]

    if 'Jorge Álvarez Máynez' in cum_metrics['candidate_name'].values:
        maynez_metrics = cum_metrics[cum_metrics['candidate_name'] == 'Jorge Álvarez Máynez'].iloc[0]

    # Create a dictionary for this specific pollster date
    result_row = {
        'date': poll_date,
        'claudia_voting_intention': row['claudia_sheinbaum'],
        'claudia_num_interaction_share': claudia_metrics['num_interaction_share'],
        'claudia_like_count_share': claudia_metrics['like_count_share'],
        'claudia_comment_count_share': claudia_metrics['comment_count_share'],
        'claudia_view_count_share': claudia_metrics['view_count_share'],
        'xochitl_voting_intention': row['xochitl_galvez'],
        'xochitl_num_interaction_share': xochitl_metrics['num_interaction_share'],
        'xochitl_like_count_share': xochitl_metrics['like_count_share'],
        'xochitl_comment_count_share': xochitl_metrics['comment_count_share'],
        'xochitl_view_count_share': xochitl_metrics['view_count_share'],
        'maynez_voting_intention': row['alvarez_maynez'],
        'maynez_num_interaction_share': maynez_metrics['num_interaction_share'],
        'maynez_like_count_share': maynez_metrics['like_count_share'],
        'maynez_comment_count_share': maynez_metrics['comment_count_share'],
        'maynez_view_count_share': maynez_metrics['view_count_share']
    }

    # Append the result for this date
    results.append(result_row)

# Step 4: Convert the results list into a final DataFrame
final_df = pd.DataFrame(results)

# Save the final DataFrame to CSV
final_df.to_csv(base_path + '/comparison_with_pollster_data.csv', index=False)

print("Comparison data created and saved to 'comparison_with_pollster_data.csv'")

comparison_df = final_df.copy()
comparison_df = comparison_df.iloc[1:] # The original data starts at january 10th, so no cumulative metrics had started being measured yet.
print("First initial rows: \n")
comparison_df.info()

"""As expected, the first 5 rows of the comparison dataframe will have null values due to the cero values discovered and discussed during *Cleaning the dataset - Important note on metrics* phase."""

print("Last 5 rows: \n")
comparison_df.tail()

"""Having explained the null values, regression and correlation analysis to test hypothesis will be made using the entire dates for the num_interaction column, for the rest of the metrics, the same analysis will be made beginning april."""

# Avoiding null values
after_april_df = comparison_df[comparison_df['date'] >= '2024-04-10']

after_april_df.info()

"""#### Further Splitting Original DataFrame
In order to fully understand voter behaviour it is necessary to split the columns explored before by platform, in an attempt to further understand relationships among candidates and platforms so a single (or multiple) ultimate predictors can be selected.
"""

# Ensure we are comparing date components only
df['date'] = pd.to_datetime(df['datetime']).dt.date  # Create a date column without the time part

# Initialize an empty list to store the cumulative results
results = []

# Step 3: Loop through each row in the pollster_data to calculate cumulative metrics up to that date
for idx, row in pollster_data.iterrows():
    poll_date = row['date']

    # Filter the original df up to the current pollster date
    # Convert poll_date to datetime.date
    filtered_df = df.loc[df['date'] <= poll_date.date()]  # Compare datetime.date objects

    # Group by platform and candidate and sum the cumulative metrics
    cum_metrics = filtered_df.groupby(['platform', 'candidate_name']).agg({
        'num_interaction': 'sum',
        'like_count': 'sum',
        'comment_count': 'sum',
        'view_count': 'sum'
    }).reset_index()

    # List of platforms to track
    platforms = ['X', 'Facebook', 'Instagram', 'Youtube']  # Adjust this list if you have other platforms

    # Create a dictionary to store the results for this date
    result_row = {'date': poll_date}

    # Loop over each platform to calculate the shares per candidate
    for platform in platforms:
        # Filter cumulative metrics for the current platform
        platform_metrics = cum_metrics[cum_metrics['platform'] == platform]

        # Calculate the total cumulative values for the platform across all candidates
        total_cum_metrics = platform_metrics[['num_interaction', 'like_count', 'comment_count', 'view_count']].sum()

        # If no data exists for this specific platform, skip to the next iteration
        if total_cum_metrics.sum() == 0:
            continue

        # Calculate the share for each candidate relative to the platform's total cumulative metrics
        platform_metrics['num_interaction_share'] = platform_metrics['num_interaction'] / total_cum_metrics['num_interaction'] * 100
        platform_metrics['like_count_share'] = platform_metrics['like_count'] / total_cum_metrics['like_count'] * 100
        platform_metrics['comment_count_share'] = platform_metrics['comment_count'] / total_cum_metrics['comment_count'] * 100
        platform_metrics['view_count_share'] = platform_metrics['view_count'] / total_cum_metrics['view_count'] * 100

        # Initialize default values for each candidate
        claudia_metrics = xochitl_metrics = maynez_metrics = {
            'num_interaction_share': 0,
            'like_count_share': 0,
            'comment_count_share': 0,
            'view_count_share': 0
        }

        # Safely extract data for each candidate if present
        if 'Claudia Sheinbaum' in platform_metrics['candidate_name'].values:
            claudia_metrics = platform_metrics[platform_metrics['candidate_name'] == 'Claudia Sheinbaum'].iloc[0]

        if 'Xóchitl Gálvez' in platform_metrics['candidate_name'].values:
            xochitl_metrics = platform_metrics[platform_metrics['candidate_name'] == 'Xóchitl Gálvez'].iloc[0]

        if 'Jorge Álvarez Máynez' in platform_metrics['candidate_name'].values:
            maynez_metrics = platform_metrics[platform_metrics['candidate_name'] == 'Jorge Álvarez Máynez'].iloc[0]

        # Add the platform-specific metrics for each candidate
        result_row[f'claudia_{platform.lower()}_num_interaction_share'] = claudia_metrics['num_interaction_share']
        result_row[f'claudia_{platform.lower()}_like_count_share'] = claudia_metrics['like_count_share']
        result_row[f'claudia_{platform.lower()}_comment_count_share'] = claudia_metrics['comment_count_share']
        result_row[f'claudia_{platform.lower()}_view_count_share'] = claudia_metrics['view_count_share']

        result_row[f'xochitl_{platform.lower()}_num_interaction_share'] = xochitl_metrics['num_interaction_share']
        result_row[f'xochitl_{platform.lower()}_like_count_share'] = xochitl_metrics['like_count_share']
        result_row[f'xochitl_{platform.lower()}_comment_count_share'] = xochitl_metrics['comment_count_share']
        result_row[f'xochitl_{platform.lower()}_view_count_share'] = xochitl_metrics['view_count_share']

        result_row[f'maynez_{platform.lower()}_num_interaction_share'] = maynez_metrics['num_interaction_share']
        result_row[f'maynez_{platform.lower()}_like_count_share'] = maynez_metrics['like_count_share']
        result_row[f'maynez_{platform.lower()}_comment_count_share'] = maynez_metrics['comment_count_share']
        result_row[f'maynez_{platform.lower()}_view_count_share'] = maynez_metrics['view_count_share']

    # Add voting intentions for the candidates from pollster data
    result_row['claudia_voting_intention'] = row['claudia_sheinbaum']
    result_row['xochitl_voting_intention'] = row['xochitl_galvez']
    result_row['maynez_voting_intention'] = row['alvarez_maynez']

    # Append the result for this date
    results.append(result_row)

# Step 4: Convert the results list into a final DataFrame
final_df = pd.DataFrame(results)

# Save the final DataFrame to CSV
final_df.to_csv('comparison_with_pollster_data_by_platform.csv', index=False)

print("Comparison data created and saved to 'comparison_with_pollster_data_by_platform.csv'")

per_platform_comparison_df = final_df.copy()
per_platform_comparison_df = per_platform_comparison_df.iloc[1:] # The original data starts at january 10th, so no cumulative metrics had started being measured yet.
per_platform_comparison_df = per_platform_comparison_df.drop(columns=['claudia_x_view_count_share',
                                                                       'xochitl_x_view_count_share',
                                                                       'maynez_x_view_count_share',
                                                                       'claudia_instagram_view_count_share',
                                                                       'xochitl_instagram_view_count_share',
                                                                       'maynez_instagram_view_count_share',
                                                                       'claudia_facebook_view_count_share',
                                                                       'xochitl_facebook_view_count_share',
                                                                       'maynez_facebook_view_count_share']) # These platforms don't have view metrics, removing them to avoid null values.
print("First initial rows: \n")
per_platform_comparison_df.head()

"""As expected, the first 5 rows of the comparison dataframe will have null values due to the cero values discovered and discussed during *Cleaning the dataset - Important note on metrics* phase."""

print("Last 5 rows: \n")
per_platform_comparison_df.tail()

"""Having explained the null values, regression and correlation analysis to test hypothesis will be made using the entire dates for the num_interaction column, for the rest of the metrics, the same analysis will be made beginning april."""

# Avoiding null values
after_per_platform_df = per_platform_comparison_df[comparison_df['date'] >= '2024-04-10']

"""## Entire Data Hypothesis Exploration
During this phase, we set up to test the relationships between the company's data and the official count for the entire combined dataframe (without splitting into platforms), as per our established hypothesis (see *Target Hypothesis* step for more info).

Exploring the data
"""

comparison_df[['date','claudia_voting_intention','claudia_num_interaction_share','xochitl_num_interaction_share','maynez_num_interaction_share']].head()

"""#### Visualizing Claudia Sheinbaum's Data

First we use the entire comparison dataframe for the number of interactions as it doesn't have null values.
"""

# Plotting Claudia's Data Over Time
plot_client_template_lineplot(
    df=comparison_df,
    x_col='date',
    y_cols=['claudia_num_interaction_share', 'claudia_voting_intention'],
    labels=['Num Interaction Share', 'Voting Intention'],
    suptitle="Claudia's Interaction Share Over Time",
    title='Comparison of interaction share and voting intention for Claudia',
    logo_y_coord = .99,
    logo_x_coord = .04
)

print("\nCorrelation with full interaction share against official voting share: \n")
print(round(comparison_df['claudia_num_interaction_share'].corr(comparison_df['claudia_voting_intention']),2))

"""A very strong negative correlation. Curious that, as the number of interactions grows, the voting intention falls.

We now move on to use the april filtered dataset due to the null values.
"""

# Correlation Matrix For Claudia Using Filtered April DataFrame
plot_correlation_matrix(after_april_df, 'claudia', logo, suptitle_dict, title_dict, logo_x_coord=0.05, logo_y_coord=1)

"""For Claudia's specific case, it can be seen that the variable that most closely tracks her voting intentions is the like_count_share (0.95 positive correlation), further visualizing it:"""

# Plotting Claudia's Data Over Time
plot_client_template_lineplot(
    df=after_april_df,
    x_col='date',
    y_cols=['claudia_like_count_share', 'claudia_voting_intention'],
    labels=['Like Count Share', 'Voting Intention'],
    suptitle="Claudia's Like Share Over Time",
    title='Comparison of likes share and voting intention for Claudia Sheinbaum',
    logo_y_coord = .99,
    logo_x_coord = .04
)

print("\nCorrelation with like share against official voting share: \n")
print(round(after_april_df['claudia_like_count_share'].corr(after_april_df['claudia_voting_intention']),2))

"""It can bee seen that in fact, like count is the most accurate predictor in voting_intention up until the final vote share.

#### Visualizing Xóchitl Gálvez's Data

First we use the entire comparison dataframe for the number of interactions as it doesn't have null values.
"""

# Plotting Claudia's Data Over Time
plot_client_template_lineplot(
    df=comparison_df,
    x_col='date',
    y_cols=['xochitl_num_interaction_share', 'xochitl_voting_intention'],
    labels=['Num Interaction Share', 'Voting Intention'],
    suptitle="Xóchitl's Interaction Share Over Time",
    title='Comparison of interaction share and voting intention for Xóchitl',
    logo_y_coord = .99,
    logo_x_coord = .04
)

print("\nCorrelation with full interaction share against official voting share: \n")
print(round(comparison_df['xochitl_num_interaction_share'].corr(comparison_df['xochitl_voting_intention']),2))

"""We can see a strong negative correlation, as the number of interactions falls, the voting intention grows.

We now move on to use the filtered april dataset due to the presence of null values.
"""

# Correlation Matrix For Xochitl Using Filtered April DataFrame
plot_correlation_matrix(after_april_df, 'xochitl', logo, suptitle_dict, title_dict, logo_x_coord=0.05, logo_y_coord=1)

"""Just as with candidate Claudia, the predictor that most closely followed the official voter intentions was the like count, although this time it wasn't as strong as it was with Claudia."""

# Plotting Claudia's Data Over Time
plot_client_template_lineplot(
    df=after_april_df,
    x_col='date',
    y_cols=['xochitl_like_count_share','xochitl_num_interaction_share', 'xochitl_voting_intention'],
    labels=['Like Count Share','Num Interaction Share', 'Voting Intention'],
    suptitle="Xóchitl's Highly Correlated Metrics Over Time",
    title='Comparison of likes share and voting intention for Xóchitl'
)

print('\nIn order of appearance in this line graph:')
print("\nCorrelation with filtered interaction share against official voting share: \n")
print(round(after_april_df['xochitl_num_interaction_share'].corr(after_april_df['xochitl_voting_intention']),2))

print("\nCorrelation with like count share against official voting share: \n")
print(round(after_april_df['xochitl_like_count_share'].corr(after_april_df['xochitl_voting_intention']),2))

"""#### Visualizing Álvarez Máynez Data

We first use the first comparison dataframe for the full time period in scope:
"""

# Plotting Claudia's Data Over Time
plot_client_template_lineplot(
    df=comparison_df,
    x_col='date',
    y_cols=['maynez_num_interaction_share', 'maynez_voting_intention'],
    labels=['Num Interaction Share', 'Voting Intention'],
    suptitle="Máynez's Interaction Share Over Time",
    title='Comparison of interaction share and voting intention for Máynez'
)

print("\nCorrelation with full interaction share against official voting share: \n")
print(round(comparison_df['maynez_num_interaction_share'].corr(comparison_df['maynez_voting_intention']),2))

"""A lot of variance can be seen on both lines (although the pollster's data seems to be more smoothed out). However, the correlation is poor."""

# Correlation Matrix For Máynez Using Filtered April DataFrame
plot_correlation_matrix(after_april_df, 'maynez', logo, suptitle_dict, title_dict, logo_x_coord=0.05, logo_y_coord=1)

"""It looks like both the number of interactions, the like count and comment count have an extremly high correlation when filtering for data after april 12th, let's explore further:"""

# Plotting Máynez's Data Over Time
plot_client_template_lineplot(
    df=after_april_df,
    x_col='date',
    y_cols=['maynez_like_count_share', 'maynez_voting_intention', 'maynez_comment_count_share', 'maynez_num_interaction_share'],
    labels=['Like Share', 'Voting Intention', 'Comment Share', 'Interaction Share'],
    suptitle="Máynez's Highly Correlated Metrics Over Time",
    title='Comparison of likes share, comment share, interaction share, and voting intention for Máynez'
)

print("\nIn order of appearance in this line graph: ")

print("\nCorrelation with like share against official voting share: \n")
print(round(after_april_df['maynez_like_count_share'].corr(after_april_df['maynez_voting_intention']),2))

print("\nCorrelation with comment count share against official voting share: \n")
print(round(after_april_df['maynez_comment_count_share'].corr(after_april_df['maynez_voting_intention']),2))

print("\nCorrelation with filtered interaction share against official voting share: \n")
print(round(after_april_df['maynez_num_interaction_share'].corr(after_april_df['maynez_voting_intention']),2))

"""It does seem to follow the trend extremely closely, however, even though the number of interactions has a .99 correlation value, we will keep going with like count share because that was the metric that most accurate followed the other candidates as well.

## Per Platform Data Hypothesis Exploration
The final step before Hypothesis testing is to see the behaviour of the trends just as we did before but this time per platform, in order to see if there is any significant evidence that tell us to test the hypothesis with the data by platform rather than on its entirety.

#### Visualizing Claudia Sheinbaum's Per Platform Data
"""

plot_client_template_lineplot(
    df=per_platform_comparison_df,
    x_col='date',
    y_cols=['claudia_voting_intention', 'claudia_x_num_interaction_share', 'claudia_youtube_num_interaction_share',
            'claudia_facebook_num_interaction_share', 'claudia_instagram_num_interaction_share'],
    labels=['Voting Intention', 'X Number of Interactions', 'YouTube Number of Interactions',
            'Facebook Number of Interactions', 'Instagram Number of Interactions'],
    suptitle="Claudia's Interactions Over Time (Per Platform)",
    title='Comparison of likes share and voting intention for Claudia',
    color_map=color_map
)

print("\nIn order of appearance in this line graph: ")

print("\nFacebook correlation with voting intention: \n")
print(round(per_platform_comparison_df['claudia_facebook_num_interaction_share'].corr(per_platform_comparison_df['claudia_voting_intention']),2))

print("\nYouTube correlation with voting intention: \n")
print(round(per_platform_comparison_df['claudia_youtube_num_interaction_share'].corr(per_platform_comparison_df['claudia_voting_intention']),2))

print("\nInstagram correlation with voting intention: \n")
print(round(per_platform_comparison_df['claudia_instagram_num_interaction_share'].corr(per_platform_comparison_df['claudia_voting_intention']),2))

print("\nX correlation with voting intention: \n")
print(round(per_platform_comparison_df['claudia_x_num_interaction_share'].corr(per_platform_comparison_df['claudia_voting_intention']),2))

"""##### Voting intentions against number of interactions per platform matrix"""

# Claudia on all platforms
plot_candidate_num_interaction_correlation(
    data=per_platform_comparison_df,
    candidate_name='claudia',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=1,
    annot_fontsize=12
)

"""All negative correlations, the strongest one being voting intention with youtube, with a correlation of -0.85.

#### Claudia Sheinbaum's metrics per platform
Using data since april 12th due to null values

##### X
"""

# X
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='claudia',
    platform='x',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""##### Instagram"""

# Instagram
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='claudia',
    platform='instagram',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""##### Facebook"""

# Facebook
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='claudia',
    platform='facebook',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""##### Youtube"""

# Youtube
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='claudia',
    platform='youtube',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""### Visualizing Xóchitl Gálvez Per Platform Data"""

# Plotting xochitl's Data Over Time Per Platform
plot_client_template_lineplot(
    df=per_platform_comparison_df,
    x_col='date',
    y_cols=['xochitl_voting_intention', 'xochitl_x_num_interaction_share','xochitl_youtube_num_interaction_share','xochitl_facebook_num_interaction_share','xochitl_instagram_num_interaction_share'],
    labels=['Voting Intention', 'X Number of Interactins','YouTube Number of Interactions','Facebook Number of Interactins','Instagram Number of Interactions'],
    suptitle="Xóchitl's Interactions Over Time (Per Platform)",
    title='Comparison of likes share and voting intention for Xóchitl',
    color_map=color_map
)

print("\nIn order of appearance in this line graph: ")

print("\nX correlation with voting intention: \n")
print(round(per_platform_comparison_df['xochitl_x_num_interaction_share'].corr(per_platform_comparison_df['xochitl_voting_intention']),2))

print("\nYouTube correlation with voting intention: \n")
print(round(per_platform_comparison_df['xochitl_youtube_num_interaction_share'].corr(per_platform_comparison_df['xochitl_voting_intention']),2))

print("\nInstagram correlation with voting intention: \n")
print(round(per_platform_comparison_df['xochitl_instagram_num_interaction_share'].corr(per_platform_comparison_df['xochitl_voting_intention']),2))

print("\nFacebook correlation with voting intention: \n")
print(round(per_platform_comparison_df['xochitl_facebook_num_interaction_share'].corr(per_platform_comparison_df['xochitl_voting_intention']),2))

"""#### Voting intentions against number of interactions per platform matrix"""

# Xochitl on all platforms
plot_candidate_num_interaction_correlation(
    data=per_platform_comparison_df,
    candidate_name='xochitl',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=1,
    annot_fontsize=12
)

"""The strongest correlation is with YouTube, a negative -0.81 correlation. The strongest positive correlation is instagram, with a correlation of 0.47.

### Xóchitl Gálvez metrics per platform
Using data from april 12th due to null values

##### X
"""

# X
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='xochitl',
    platform='x',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""##### Instagram"""

# Instagram
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='xochitl',
    platform='instagram',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""##### Facebook"""

# Facebook
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='xochitl',
    platform='facebook',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""##### Youtube"""

# Youtube
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='xochitl',
    platform='youtube',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.94,
    annot_fontsize=12
)

"""### Visualizing Álvarez Máynez Per Platform Data"""

# Plotting maynez's Data Over Time Per Platform
plot_client_template_lineplot(
    df=per_platform_comparison_df,
    x_col='date',
    y_cols=['maynez_voting_intention', 'maynez_x_num_interaction_share','maynez_youtube_num_interaction_share','maynez_facebook_num_interaction_share','maynez_instagram_num_interaction_share'],
    labels=['Voting Intention', 'X Number of Interactins','YouTube Number of Interactions','Facebook Number of Interactins','Instagram Number of Interactions'],
    suptitle="Máynez's Interactions Over Time (Per Platform)",
    title='Comparison of likes share and voting intention for Máynez',
    color_map=color_map
)

print("\nIn order of appearance in this line graph: ")

print("\nInstagram correlation with voting intention: \n")
print(round(per_platform_comparison_df['maynez_instagram_num_interaction_share'].corr(per_platform_comparison_df['maynez_voting_intention']),2))

print("\nX correlation with voting intention: \n")
print(round(per_platform_comparison_df['maynez_x_num_interaction_share'].corr(per_platform_comparison_df['maynez_voting_intention']),2))

print("\nFacebook correlation with voting intention: \n")
print(round(per_platform_comparison_df['maynez_facebook_num_interaction_share'].corr(per_platform_comparison_df['maynez_voting_intention']),2))

print("\nYouTube correlation with voting intention: \n")
print(round(per_platform_comparison_df['maynez_youtube_num_interaction_share'].corr(per_platform_comparison_df['maynez_voting_intention']),2))

"""#### Voting intentions against number of interactions per platform matrix"""

# Máynez on all platforms
plot_candidate_num_interaction_correlation(
    data=per_platform_comparison_df,
    candidate_name='maynez',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=1,
    annot_fontsize=12
)

"""In Álvarez Máynez case, Facebook is the most correlated predictor when it comes to correlation with voting intention. With a positive correlation of 0.74

### Álvarez Máynez metrics per platform
Using data from april 12th due to null values

##### X
"""

# X
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='maynez',
    platform='x',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.99,
    annot_fontsize=12
)

"""##### Instagram"""

# Instagram
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='maynez',
    platform='instagram',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.99,
    annot_fontsize=12
)

"""##### Facebook"""

# Facebook
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='maynez',
    platform='facebook',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.99,
    annot_fontsize=12
)

"""##### Youtube"""

# Youtube
plot_platform_correlation_matrix(
    data=after_per_platform_df,
    candidate_name='maynez',
    platform='youtube',
    logo=logo,
    suptitle_dict=suptitle_dict,
    title_dict=title_dict,
    logo_x_coord=0.03,
    logo_y_coord=0.99,
    annot_fontsize=12
)

"""## Hypothesis Testing
On this step, we set on to choose the highest correlations to the respective vote count and test to see if they have statistical significance and any predictive power in final vote count for the respective candidates. We choose to select at least 1 *all-platforms* metric for each candidate and at least 1 *platform* specific metric, to compare against their vote count.

### Selecting all-platform metrics
First we select the num_interaction metrics for the entire period (jan-may)
"""

# Apply the function to compare with 'claudia_voting_intention' as an example
candidate_names = ['maynez','xochitl','claudia']
chosen_high_correlations = pd.DataFrame()

for name in candidate_names:
  temporal_df = comparison_df[[f'{name}_num_interaction_share',f'{name}_voting_intention']]
  high_correlations = calculate_correlations(temporal_df, f'{name}_voting_intention')
  chosen_high_correlations = pd.concat([chosen_high_correlations, high_correlations], ignore_index=True)

chosen_high_correlations

"""Then we select the metrics per candidate for period april to may:"""

# Apply the function to compare with 'claudia_voting_intention' as an example
candidate_names = ['maynez','xochitl','claudia']

for name in candidate_names:
  temporal_df = after_april_df[[f'{name}_voting_intention',f'{name}_num_interaction_share', f'{name}_like_count_share',f'{name}_comment_count_share']]
  high_correlations = calculate_correlations(temporal_df, f'{name}_voting_intention')
  chosen_high_correlations = pd.concat([chosen_high_correlations, high_correlations], ignore_index=True)

chosen_high_correlations

"""### Selecting per-platform metrics
Finally, we select the highest correlations by platform, following the same technique:
"""

# Apply the function to compare with 'claudia_voting_intention' as an example
candidate_names = ['maynez','xochitl','claudia']
platfroms = ['x','youtube','facebook','instagram']

for name in candidate_names:
  for platform in platfroms:
    temporal_df = after_per_platform_df[[f'{name}_voting_intention',
                                 f'{name}_{platform}_num_interaction_share',
                                 f'{name}_{platform}_like_count_share',
                                 f'{name}_{platform}_comment_count_share']]
    high_correlations = calculate_correlations(temporal_df, f'{name}_voting_intention')
    chosen_high_correlations = pd.concat([chosen_high_correlations, high_correlations], ignore_index=True)

chosen_high_correlations

"""### Dataframe gathering
After selecting the highest correlations, we set up to gather them together in two dataframes:
- **before_april_df:** 2 num_interactions (Xochitl and Claudia) and their respective voting intentions for the period.
- **after_april_df:** The remaining metrics and each candidate voting intentions starting april.
"""

# First DataFrame
before_april_df = comparison_df[['xochitl_num_interaction_share',
                                 'xochitl_voting_intention',
                                 'claudia_num_interaction_share',
                                 'claudia_voting_intention']]
before_april_df.info()

len(after_per_platform_df)

# Second DataFrame
after_april_df = after_april_df[['date',
                                 'xochitl_voting_intention',
                                 'claudia_voting_intention',
                                 'maynez_voting_intention',
                                 'maynez_num_interaction_share',
                                 'maynez_like_count_share',
                                 'maynez_comment_count_share',
                                 'xochitl_num_interaction_share',
                                 'xochitl_like_count_share',
                                 'xochitl_comment_count_share',
                                 'claudia_like_count_share',
                                 'claudia_num_interaction_share']]

after_april_df_2 = after_per_platform_df[['maynez_x_num_interaction_share',
                                          'maynez_x_comment_count_share',
                                          'maynez_x_like_count_share',
                                          'maynez_youtube_num_interaction_share',
                                          'maynez_youtube_like_count_share',
                                          'maynez_youtube_comment_count_share',
                                          'maynez_facebook_like_count_share',
                                          'maynez_facebook_num_interaction_share',
                                          'maynez_instagram_num_interaction_share',
                                          'maynez_instagram_like_count_share',
                                          'maynez_instagram_comment_count_share',
                                          'xochitl_x_num_interaction_share',
                                          'xochitl_x_comment_count_share',
                                          'xochitl_youtube_num_interaction_share',
                                          'xochitl_youtube_comment_count_share',
                                          'xochitl_youtube_like_count_share',
                                          'xochitl_facebook_num_interaction_share',
                                          'xochitl_facebook_comment_count_share',
                                          'xochitl_facebook_like_count_share',
                                          'xochitl_instagram_like_count_share',
                                          'xochitl_instagram_comment_count_share',
                                          'xochitl_instagram_num_interaction_share',
                                          'claudia_x_like_count_share',
                                          'claudia_x_num_interaction_share',
                                          'claudia_youtube_num_interaction_share',
                                          'claudia_youtube_comment_count_share',
                                          'claudia_youtube_like_count_share',
                                          'claudia_facebook_num_interaction_share',
                                          'claudia_facebook_comment_count_share',
                                          'claudia_facebook_like_count_share',
                                          'claudia_instagram_like_count_share',
                                          'claudia_instagram_comment_count_share',
                                          'claudia_instagram_num_interaction_share']]


after_april_df_together = pd.concat([after_april_df, after_april_df_2], axis=1)
after_april_df_together.info()

"""### Pearson and Spearman Significance Testing
The first hypothesis test is applying significance tests on both correlation metrics (Pearson and Spearman).

#### Testing initial dates (jan - may) *num_interactions*
Only testing for Claudia and Xóchitl due to section's *Selecting all platforms metrics* result of Maynez not having a correlation above 0.5 when comparing total num_interaction vs vote intention.
"""

# Dictionary to store results
significance_results = {}

# Define pairs for testing
pairs_to_test = {
    "claudia": ("claudia_num_interaction_share", "claudia_voting_intention"),
    "xochitl": ("xochitl_num_interaction_share", "xochitl_voting_intention")
}

# Loop through each pair and apply Pearson and Spearman tests
for candidate, (interaction_col, voting_col) in pairs_to_test.items():
    # Pearson correlation and p-value
    pearson_corr, pearson_p_value = pearsonr(before_april_df[interaction_col], before_april_df[voting_col])

    # Spearman rank correlation and p-value
    spearman_corr, spearman_p_value = spearmanr(before_april_df[interaction_col], before_april_df[voting_col])

    # Store results in the dictionary
    significance_results[candidate] = {
        "Pearson Correlation": pearson_corr,
        "Pearson p-value": pearson_p_value,
        "Spearman Correlation": spearman_corr,
        "Spearman p-value": spearman_p_value
    }

# Display the results
for candidate, results in significance_results.items():
    print(f"\nSignificance test results for {candidate.capitalize()}:")
    for test_name, value in results.items():
        print(f"{test_name}: {value:.4f}")

"""##### Interpretation
The statistical tests reveal a strong, statistically significant negative relationship between engagement metrics (specifically num_interaction_share) and voting intentions for both Xóchitl and Claudia. This relationship holds across both linear (Pearson) and monotonic (Spearman) correlations. Notably, Claudia’s Spearman correlation of -0.952 indicates an exceptionally strong monotonic association between her engagement metrics and voting intentions, suggesting that as her engagement share decreases, her voting intention score tends to increase, or vice versa.

#### Testing after april metrics (april-may)
Given that we count with multiple high-enough absolute correlations, we select the strongest ones (above 0.9 absolute *pearson-correlation* level).
"""

# Initialize a dictionary to store results for each candidate
results = {
    'candidate': [],
    'metric': [],
    'pearson_correlation': [],
    'pearson_p_value': [],
    'spearman_correlation': [],
    'spearman_p_value': []
}

# Define candidates and their corresponding columns in the DataFrame
candidates = {
    'xochitl': ['xochitl_num_interaction_share', 'xochitl_like_count_share', 'xochitl_comment_count_share',
                'xochitl_x_num_interaction_share', 'xochitl_x_comment_count_share', 'xochitl_youtube_num_interaction_share',
                'xochitl_youtube_comment_count_share', 'xochitl_youtube_like_count_share', 'xochitl_facebook_num_interaction_share',
                'xochitl_facebook_comment_count_share', 'xochitl_facebook_like_count_share', 'xochitl_instagram_like_count_share',
                'xochitl_instagram_comment_count_share', 'xochitl_instagram_num_interaction_share'],
    'claudia': ['claudia_num_interaction_share', 'claudia_like_count_share', 'claudia_x_num_interaction_share',
                'claudia_youtube_num_interaction_share', 'claudia_youtube_comment_count_share', 'claudia_youtube_like_count_share',
                'claudia_facebook_num_interaction_share', 'claudia_facebook_comment_count_share', 'claudia_facebook_like_count_share',
                'claudia_instagram_like_count_share', 'claudia_instagram_comment_count_share', 'claudia_instagram_num_interaction_share'],
    'maynez': ['maynez_num_interaction_share', 'maynez_like_count_share', 'maynez_comment_count_share',
               'maynez_x_num_interaction_share', 'maynez_x_comment_count_share', 'maynez_x_like_count_share',
               'maynez_youtube_num_interaction_share', 'maynez_youtube_like_count_share', 'maynez_youtube_comment_count_share',
               'maynez_facebook_like_count_share', 'maynez_facebook_num_interaction_share', 'maynez_instagram_num_interaction_share',
               'maynez_instagram_like_count_share', 'maynez_instagram_comment_count_share']
}

# Loop through each candidate and their metrics
for candidate, metrics in candidates.items():
    voting_intention_col = f'{candidate}_voting_intention'
    for metric in metrics:
        # Calculate Pearson correlation and p-value
        pearson_corr, pearson_p = pearsonr(after_april_df_together[metric], after_april_df_together[voting_intention_col])

        # Calculate Spearman correlation and p-value
        spearman_corr, spearman_p = spearmanr(after_april_df_together[metric], after_april_df_together[voting_intention_col])

        # Append the results to the dictionary
        results['candidate'].append(candidate)
        results['metric'].append(metric)
        results['pearson_correlation'].append(pearson_corr)
        results['pearson_p_value'].append(pearson_p)
        results['spearman_correlation'].append(spearman_corr)
        results['spearman_p_value'].append(spearman_p)

# Convert the results dictionary into a DataFrame for easy viewing
correlation_results_df = pd.DataFrame(results)

# Display the results
correlation_results_df = correlation_results_df[abs(correlation_results_df['pearson_correlation']) > 0.9].sort_values(by='pearson_correlation', ascending=False)
correlation_results_df

"""##### Positive Strong Correlation Interpretation
The correlation results indicate strong links between social media engagement metrics and voting intentions for the candidates, showing both positive and negative relationships across platforms. For instance, **Xóchitl's Instagram like count** share has extremely high positive correlations with voting intentions (Pearson: 0.9899, Spearman: 0.9842), signaling a direct, consistent connection between engagement and support on this platform. Similarly, **Máynez's engagement, especially on Instagram and YouTube**, shows strong positive correlations, highlighting the influence of these platforms' user interactions on his public support. <br>

##### Top positive correlations for each candidate:

**Claudia's Instagram Like Count Share vs Voting Intentions**
"""

# Claudia Instagram Like Count Share vs Voting Intentions
plot_client_template_lineplot(df = after_april_df_together,
                              x_col='date',
                              y_cols=['claudia_instagram_like_count_share','claudia_voting_intention'],
                              labels = ['Share of Likes on Instagram', 'Voting Intention'],
                              suptitle="Claudia's Interactions and Voting Intentions Over Time",
                              title='Comparison of number of interactions vs voting intention for Claudia',
                              color_map=color_map)

print("\nClaudia's correlation between Bloomberg's voting intentions and his share of Instagram's likes:\n")
print(after_april_df_together['claudia_voting_intention'].corr(after_april_df_together['claudia_instagram_like_count_share']))

"""**Xochitl's Instagram Like Count Share vs Bloomberg's Voting Intentions**"""

# Xochitl Instagram Like Count Share vs Voting Intentions
plot_client_template_lineplot(df = after_april_df_together,
                              x_col='date',
                              y_cols=[ 'xochitl_instagram_like_count_share','xochitl_voting_intention'],
                              labels = ['Instagram Like Count Share', 'Voting Intention'],
                              suptitle="Xóchitl's Instagram Like Count vs Voting Intentions",
                              title='Comparison of likes share in ig and voting intention for Xóchitl',
                              color_map=color_map)

print("\nXóchitl's correlation between Bloomberg's voting intentions and his share of Instagram's likes:\n")
print(after_april_df_together['xochitl_voting_intention'].corr(after_april_df_together['xochitl_instagram_like_count_share']))

"""**Máynez share of number of interactions in all platforms vs X-only number of interactions vs Bloomberg's voting intentions**"""

# Maynez total and x "number of interactions" vs Voting Intentions
plot_client_template_lineplot(df = after_april_df_together,
                              x_col='date',
                              y_cols=['maynez_num_interaction_share','maynez_x_num_interaction_share','maynez_voting_intention'],
                              labels = ['Total Number of Interactions Share','X Number of Interactions Share', 'Voting Intention'],
                              suptitle="Máynez's Interactions and Voting Intentions Over Time",
                              title='Comparison of number of interactions vs voting intention for Máynez',
                              color_map=color_map)

print("\nMáynez's correlation between Bloomberg's voting intentions and his share of total number of interactions:\n")
print(after_april_df_together['maynez_voting_intention'].corr(after_april_df_together['maynez_num_interaction_share']))

print("\nMáynez's correlation between Bloomberg's voting intentions and his share of X's number of interactions:\n")
print(after_april_df_together['maynez_voting_intention'].corr(after_april_df_together['maynez_x_num_interaction_share']))

"""##### Negative Strong Correlation Interpretation
On the other hand, some metrics reveal high negative correlations, suggesting that lower engagement on certain platforms can coincide with higher voting intentions. For example, Xóchitl’s Facebook and YouTube interaction shares have strong negative correlations with voting intentions (e.g., Pearson: -0.9675 on YouTube, Spearman: -0.9956), as does Claudia’s engagement on YouTube and Facebook (e.g., Pearson: -0.9744, Spearman: -0.9965 on YouTube). These findings suggest that reduced engagement on these platforms may still align with rising public support. All correlations are statistically significant (with very low p-values), reinforcing the credibility of these relationships and showing that social media engagement on specific platforms can closely track public support trends for the candidates.

##### Top negative correlations for each candidate
Máynez doesn't have negative correlations above 0.9

Claudia's Youtube Total Number of Interactions vs Bloomberg's Voting Intention
"""

# Claudia's YouTube interactions vs voting intentions
plot_client_template_lineplot(
    df=after_april_df_together,
    x_col='date',
    y_cols=['claudia_youtube_num_interaction_share','claudia_voting_intention'],
    labels=['Total Youtube Number of Interactions Share', 'Voting Intention'],
    suptitle="Claudia's Interactions and Voting Intentions Over Time",
    title='Comparison of number of interactions in YouTube vs voting intention for Claudia'
)

print("\nClaudia's correlation between Bloomberg's voting intentions and her share of Youtube number of interactions:\n")
print(after_april_df_together['claudia_voting_intention'].corr(after_april_df_together['claudia_youtube_num_interaction_share']))

"""**Xóchitl's Youtube Total Number of Interactions vs Bloomberg's Voting Intention**"""

# xochitl_youtube_num_interaction_share vs voting_intention
plot_client_template_lineplot(df = after_april_df_together,
                              x_col='date',
                              y_cols=['xochitl_youtube_num_interaction_share','xochitl_voting_intention'],
                              labels = ['Total Youtube Number of Interactions Share', 'Voting Intention'],
                              suptitle="Xóchitl's Interactions and Voting Intentions Over Time",
                              title='Comparison of number of interactions in youtube vs voting intention for Xóchitl',
                              color_map=color_map)
print("\nXóchitl's correlation between Bloomberg's voting intentions and her Youtube number of interactions:\n")
print(after_april_df_together['xochitl_voting_intention'].corr(after_april_df_together['xochitl_youtube_num_interaction_share']))

"""### Simple Linear Regression Analysis

#### Testing Jan - May

Only testing for Claudia and Xóchitl due to section's (*Selecting all platforms metrics*) result of Maynez not having a correlation above 0.5 when comparing total num_interaction vs vote intention.
"""

# "comparison_df" is the dataframe that has the entire length of dates (jan-may)
# List of metrics to measure
metrics = [
    'claudia_num_interaction_share',
    'xochitl_num_interaction_share',
]

# List to measure against
voting_intention_columns = {
    'claudia': 'claudia_voting_intention',
    'xochitl': 'xochitl_voting_intention'
}

# Run the regression for each metric
results = {}
for metric in metrics:
    # Determine which candidate's voting intention to use based on the metric name
    candidate = next(cand for cand in voting_intention_columns if cand in metric)
    voting_column = voting_intention_columns[candidate]

    # Run the regression and store the result
    results[metric] = simple_linear_regression(before_april_df, metric, voting_column)

"""##### Interpretation
The regression analysis shows a strong negative relationship between social media interactions and voting intentions for both Claudia and Xóchitl. Specifically:

- For Claudia, as num_interaction_share increases by 1 unit, her voting intention decreases by approximately 0.39 points. The model explains 62% of the variation in voting intention (R-squared = 0.62) and is statistically significant (p < 0.001).

- For Xóchitl, as num_interaction_share increases by 1 unit, her voting intention decreases by about 0.19 points. This model explains 66% of the voting intention variation (R-squared = 0.66) and is also statistically significant (p < 0.001).

In summary, increased interaction share on social media for both candidates is associated with a decrease in voting intentions, suggesting an inverse relationship.

#### Testing Apr - May
First we select the absolute correlations above 0.9 as seen on section (*Testing after april metrics (april - may)*) as these are the strongest correlations and thus more probably represent predictive power.
"""

strong_corr_list = list(correlation_results_df['metric'])
strong_corr_list.extend(['maynez_voting_intention','xochitl_voting_intention','claudia_voting_intention'])
strong_correlations_df = after_april_df_together[strong_corr_list]

"""After selecting all necessary metrics, we iterate and test among the given candidates and their chosen social media metrics.

##### Testing for Claudia
"""

# "comparison_df" is the dataframe that has the entire length of dates (jan-may)
# List of metrics to measure
metrics = [
    'claudia_youtube_num_interaction_share',
    'claudia_instagram_like_count_share',
    'claudia_like_count_share',
    'claudia_instagram_comment_count_share',
    'claudia_facebook_num_interaction_share',
    ]

# List to measure against
voting_intention_columns = {
    'claudia': 'claudia_voting_intention',
}

# Run the regression for each metric
results = {}
for metric in metrics:
    # Determine which candidate's voting intention to use based on the metric name
    candidate = next(cand for cand in voting_intention_columns if cand in metric)
    voting_column = voting_intention_columns[candidate]

    # Run the regression and store the result
    results[metric] = simple_linear_regression(strong_correlations_df, metric, voting_column)

"""##### **Claudia interpretation**

- **YouTube Interactions:** Strong negative relationship with voting intention (R² = 0.95). As her YouTube interactions decrease, her voting intention seems to increase. This suggests that fewer interactions on YouTube align with higher public support.

- **Instagram Likes:** Very strong positive relationship (R² = 0.97). An increase in her Instagram like share is linked to a higher voting intention, making Instagram likes a powerful indicator of her popularity.

- **Total Likes:** Positive impact (R² = 0.91). Similar to Instagram, an increase in her overall like count is associated with higher voting intention.

- **Instagram Comments:** Positive but slightly weaker link (R² = 0.87). More comments on Instagram correlate with increased voting support, though not as strongly as likes.

- **Facebook Interactions:** Strong negative correlation (R² = 0.83). A decrease in Facebook interactions tends to coincide with higher voting intention, similar to the YouTube trend.

In summary, Instagram likes are Claudia’s strongest positive indicator, while fewer interactions on YouTube and Facebook seem to align with higher voting intention.

##### Testing for Xóchitl
"""

# "comparison_df" is the dataframe that has the entire length of dates (jan-may)
# List of metrics to measure
metrics = [
    'xochitl_instagram_like_count_share',
    'xochitl_facebook_num_interaction_share',
    'xochitl_num_interaction_share',
    'xochitl_x_num_interaction_share',
    'xochitl_youtube_num_interaction_share'
    ]

# List to measure against
voting_intention_columns = {
    'xochitl': 'xochitl_voting_intention'
}

# Run the regression for each metric
results = {}
for metric in metrics:
    # Determine which candidate's voting intention to use based on the metric name
    candidate = next(cand for cand in voting_intention_columns if cand in metric)
    voting_column = voting_intention_columns[candidate]

    # Run the regression and store the result
    results[metric] = simple_linear_regression(strong_correlations_df, metric, voting_column)

"""##### **Xóchitl Interpretations**

- **Instagram Likes:** Extremely strong positive relationship (R² = 0.98). An increase in Instagram like count share is closely associated with higher voting intention, making it a key indicator of support.

- **Facebook Interactions:** Strong negative relationship (R² = 0.87). As Facebook interactions decrease, voting intention for Xóchitl appears to rise, suggesting that Facebook engagement may inversely correlate with her popularity.

- **Total Interactions:** Negative correlation (R² = 0.88). Fewer overall interactions across platforms are associated with an increase in voting intention, indicating that high engagement may not directly reflect public support.

- **X Interactions:** Strong negative relationship (R² = 0.89). Decreased engagement on X is linked to higher voting intention, similar to Facebook, showing that reduced activity might correspond with increased support.

- **YouTube Interactions:** Very strong negative correlation (R² = 0.94). Lower interaction on YouTube corresponds with higher voting intention, reinforcing the trend where reduced platform engagement aligns with more public support.

In short, Instagram likes are a strong positive indicator of Xóchitl’s popularity, while lower engagement on Facebook, YouTube, and X tends to coincide with higher voting intention.

##### Testing for Máynez
"""

# "comparison_df" is the dataframe that has the entire length of dates (jan-may)
# List of metrics to measure
metrics = [
    'maynez_num_interaction_share',
    'maynez_x_num_interaction_share',
    'maynez_like_count_share',
    'maynez_youtube_num_interaction_share',
    'maynez_instagram_num_interaction_share',
    'maynez_x_comment_count_share',
    'maynez_comment_count_share',
    'maynez_instagram_like_count_share',
    'maynez_instagram_comment_count_share',
    'maynez_x_like_count_share'
    ]

# List to measure against
voting_intention_columns = {
    'maynez': 'maynez_voting_intention'
}

# Run the regression for each metric
results = {}
for metric in metrics:
    # Determine which candidate's voting intention to use based on the metric name
    candidate = next(cand for cand in voting_intention_columns if cand in metric)
    voting_column = voting_intention_columns[candidate]

    # Run the regression and store the result
    results[metric] = simple_linear_regression(strong_correlations_df, metric, voting_column)

"""##### **Máynez Interpretations**

- **Total Interactions:** Very strong positive relationship (R² = 0.97). An increase in total interaction share is closely linked with higher voting intention for Máynez, indicating that overall engagement is a strong indicator of support.

- **X Interactions:** Also very strong positive correlation (R² = 0.97). More interactions on X correlate with increased voting intention, emphasizing X as a relevant platform for predicting support.

- **Like Count:** Strong positive correlation (R² = 0.95). Higher like count share is associated with increased voting intention, suggesting that likes are a significant indicator of popularity.

- **YouTube Interactions:** Very strong positive relationship (R² = 0.95). Increased YouTube interactions also align with a rise in voting intention, indicating that engagement on this platform is beneficial for Máynez’s support.

- **Instagram Interactions:** Strong positive correlation (R² = 0.94). Engagement on Instagram, such as total interactions, aligns positively with voting intention, confirming Instagram’s relevance.

- **X Comments:** Strong positive relationship (R² = 0.94). Higher comment count on X correlates with increased voting intention, showing that interactions beyond likes, like comments, are also predictive of support.

- **Total Comment Count:** Positive correlation (R² = 0.88). Higher comment counts overall correspond with increased voting intention, though slightly less strongly than other metrics.

- **Instagram Likes:** Strong positive correlation (R² = 0.87). Increased like count on Instagram is associated with higher voting intention, underscoring the value of likes on this platform.

- **Instagram Comments:** Positive correlation (R² = 0.83). While weaker than other metrics, more comments on Instagram also positively predict voting intention.

In summary, Máynez’s voting intention aligns positively across multiple interaction types and platforms, with particular strength in total interactions, X, and YouTube metrics.

## Conclusions

This analysis successfully demonstrates that social media engagement metrics (specially the ones analyzed in *Simple Linear Regression Analysis*) are valuable predictors of public support, shedding light on how online activity translates to political backing. It also highlights platform-specific engagement trends that could serve as a guide for campaign strategies. For future work, applying these insights over time could further validate the predictive power of social media metrics on electoral outcomes, potentially offering real-time sentiment tracking for strategic decision-making.
"""